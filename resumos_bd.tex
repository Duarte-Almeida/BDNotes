\documentclass[oneside]{book}

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{float}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{interval}
\usepackage{enumitem, xcolor}
\usepackage{listingsutf8}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{xcolor}
\usepackage{colortbl}
\usepackage{subfig}
\usepackage{multirow}

\usepackage{caption}


\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}

\newtheorem{theorem}{Teorema}
\newtheorem{lemma}{Lema}

\lstset{inputencoding=utf8/latin1}

\usepackage{xcolor,listings}
\usepackage{textcomp}
\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{HTML}{C42043}
\definecolor{backcolour}{HTML}{F2F2F2}
\definecolor{bookColor}{cmyk}{0,0,0,0.90}  
\color{bookColor}
\lstset{upquote=true}
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\numberstyle,
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
}
\lstset{style=mystyle}
\newcommand\numberstyle[1]{%
    \footnotesize
    \color{codegray}%
    \ttfamily
    \ifnum#1<10 0\fi#1 |%
}

\graphicspath{ {./figures} }

\theoremstyle{definition}
\newtheorem{definition}{Definição}
\newcommand*{\rom}[1]{\expandafter\@slowromancap\romannumeral #1@}
\newgeometry{vmargin={20mm}, hmargin={22mm,22mm}}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\setlength\parindent{0pt}

\title{Apontamentos de BD}
\author{João Aragonez}
\date{}

\begin{document}

\maketitle
\tableofcontents

\chapter{Conceitos Iniciais}

\section{Sistemas de informação}
\begin{definition}[Sistemas de Informação]
    Consiste na área que estuda as atividades de pendor estratégico, operacional e de gestão subjacentes à recolha, processamento, armazenamento, distribuição e uso de informação e de tecnologias associadas, tanto pela sociedade como por organizações. \\
    \indent Também é comum definir SI como a interação entre tecnologia e processos de negócio, mais concretamente, a gestão de 3 componentes fundamentais: \textbf{dados, tecnologia e pessoas}.
\end{definition}
Entre outros, menciona-se os seguintes tipos de sistemas de informação:
\begin{itemize}
    \itemsep0cm
    \item[--] \textit{ERP} (\textit{Enterprise Resource Planning});
    \item[--] SIG (Sistemas de Informação Geográfica);
    \item[--] Sistemas de \textit{office automation};
    \item[--] Sistemas de \textit{Business Intelligence};
    \item[--] Sistemas Especialistas;
    \item[--] \textit{WWW} (\textit{World Wide Web}).   
\end{itemize}

\section{Sistemas de Gestão de Bases de Dados (SGBD)}

\begin{definition}[Base de Dados]
    Consiste em nada mais que conjuntos de dados interligados.
\end{definition}

\begin{definition}[Sistema de Gestão de Bases de Dados]
    Consiste numa ferramenta de software desenhada para a manutenção e gestão de bases de dados
\end{definition}

Dado que os sistemas operativos atuais se encontram munidos de um sistema de ficheiros, perfeitamente capazes de lidar com o armazenamento de informação, surge a seguinte questão: \textit{porquê usar um SGBD?} A verdade é que os sistemas de informação apresentam necessidades comuns que não são cobertas por sistemas de ficheiros. Assim, os SGBD têm por objetivo realizar:

\begin{itemize}
    \itemsep0cm
    \item[--] Controlo de redundância;
    \item[--] Segurança e controlo de acessos, dada a heterogeneidade de utilizadores e de dados;
    \item[--] Persistência de dados;
    \item[--] Oferecer múltiplas interfaces para diferentes tipos de utilizadores;
    \item[--] Representar relações complexas;
    \item[--] Assegurar constrangimentos de integridade sobre os dados;
    \item[--] Realizar controlo de concorrência, por forma a manter os dados consistentes;
    \item[--] Permitir que uma grande quantidade de iterrogações (\textit{queries}) possam ser feitas sobre os dados sem necessidade de programação adicional;   
    \item[--] Garantir tolerância a faltas (e.g., realizando \textit{backups}). 
\end{itemize}

\subsection{Vantagens dos SGBD's}
\vspace{0.25cm}

\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{Independência dos dados}: encapsulando o modo real de representação e armazenamento dos dados, os SGBD's disponibilizam uma visão abstrata dos dados.
    \item[--]\textbf{Acesso Eficiente aos Dados}: os SGBD incorporam técnicas para armazenamento e recolha eficiente dos dados;
    \item[--]\textbf{Integridade dos dados e segurança}: os SGBD garantem a aplicação de restrições de integridade no acesso e manipulação de dados;
    \item[--]\textbf{Capacidade de administração dos dados}: é possível mudar a representação dos dados por forma a minimizar a redundância e melhorar o armazenamento de forma totalmente transparente ao utilizador;
    \item[--]\textbf{Acesso Concorrente e Recuperação de Falhas}: existe suporte à concorrência no acesso aos dados, garantido um efeito semelhante a um acesso sequencial;
    \item[--]\textbf{Redução do tempo de desenvolvimento de aplicações}: disponibiliza uma interface de alto nível para os dados e funções de acesso comuns, sendo para além disso uma componente da aplicação que não necessita de ser verificada.  
\end{itemize}

\subsection{Desvantagens dos SGBD's}

\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{Overhead demasiado elevado}: requer investimento em hardware, software e formação no uso destes sistemas;
    \item[--]\textbf{Tratamento demasiado geral}: Dependendo da aplicação, os mecanismos de segurança, controlo de concorrência, integridade e de recuperação de faltas podem não ser suficientes;
    \item[--]\textbf{Desadequados a sistemas com requisitos de tempo-real};
    \item[--]\textbf{Desadequados a bases de dados simples/imutáveis ou sem concorrência de acessos};
    \item[--]\textbf{Desadequados a certos tipos de dados, como texto}.   
\end{itemize}

\section{Modelos e Níveis de Abstração nos SI}

Num SGBD, os dados podem ser descritos segundo diversos modelos, que correspondem a diferentes níveis de abstração acerca da sua representação/armezenamento:
\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{Modelo Conceptual} (ou esquema externo), que descreve como os utilizadores vêm os dados. Permite particulizar o acesso aos dados através de \textbf{Vistas} - conjuntos de registos visíveis para grupos específicos de utilizadores e apenas computados quando necessário (i.e., não são explicitamente armazenados). Este nível permite \textbf{independência dos dados lógicos}, pois alterações ao esquema lógico requerem unicamente redefinição de vistas, pelo que o utilizador não se dará conta de eventuais extensões e modificações das estruturas de dados.
    \item[--]\textbf{Modelo Lógico} (ou esquema conceptual), que corresponde à estrutura lógica dos dados (e.g., relações existentes no modelo relacional). Este nível permite \textbf{independência dos dados físicos}, pois a organização física nada influi sobre o esquema lógico dos dados.
    \item[--]\textbf{Modelo Interno} (ou esquema físico), que especifica os detalhes de armazenamento das relações (e.g., definição de tipos de ficheiros a utilizar e de índices). 
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.6]{cap1/modelo_ansi.png}
    \caption{Modelo \textit{ANSI/SPARC}}
\end{figure}

\section{Modelos de Dados}

\begin{definition}[Modelo de Dados]
    Coleção de conceitos para descrever dados, relacionamentos, semântica de dados e restrições.
\end{definition}
\begin{definition}[Esquema]
    Descrição de uma coleção específica de dados à luz de um dado modelo de dados (i.e., o resultado da aplicação de um modelo de dados um conjunto de dados específico).
\end{definition}

Entre outros modelos de dados, destacam-se o \textbf{Modelo Relacional}, o \textbf{Modelo Entidade-Associação}, o \textbf{Modelo Baseado em Objetos}, \textbf{Modelos de Dados Semi-Estruturados} (como \textit{XML/JSON}), ou os \textbf{Modelos em Rede e Hierárquicos} (não usados atualmente).\\
\indent Contudo, o modelo de dados mais amplamente difuso nos SGDB é o \textbf{modelo relacional}, cujos conceitos fundamentais são a \textbf{relação} (i.e., um tuplo de atributos) e o \textbf{esquema}, que corresponde à especificação do nome da relação e do nome e tipo dos seus atributos. \\
\indent Numa fase mais inicial do desenvolvimento de bases de dados, podem-se usar \textbf{Modelos Semânticos de Dados}, passíveis de serem diretamente traduzidos para o modelo relacional. O exemplo mais paradigmático destes modelos é o \textbf{Modelo Entidade-Associação}.

\section{Arquitetura dos SGBD}

As arquiteturas dos SGBD procuram, por um lado, maximizar a \textbf{eficiência e escalabilidade}, mais concretamente, acelerando as interrogações sobre os dados. A figura abaixo exibe as fases que compõem o processamento de uma \textit{query}: \textbf{análise e tradução}, \textbf{otimização} e  \textbf{avaliação}.

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.5]{cap1/arquitetura.png}
    \caption{Processamento de uma \textit{query}}
\end{figure}

Por outro lado, procuram maximizar a \textbf{concorrência e a robustez}, existindo um \textbf{gestor de transações} para lidar com questões de concorrência, bem como um \textbf{gestor de recuperação} e um \textbf{gestor de \textit{locks}}.

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.75]{cap1/arquitetura_geral.png}
    \caption{Arquitetura de um SGBD}
\end{figure}

\section{Conceção de Bases de Dados}

O processo de conceção de um base de dados incide inicialmente no \textbf{desenho lógico}, i.e., sobre o \textbf{esquema} a adotar. Para este decisão contribuem fatores associados ao \textbf{Negócio} (como determinar quais os atributos mais relevantes para o domínio em questão), bem como fatores de \textbf{Engenharia}, como definição de esquemas e distribuição dos atributos por estes.

\section{Utilizadores de Bases de Dados}

\begin{itemize}
    \itemsep0cm
    \item[--] \textbf{Implementadores de Bases de Dados;}
    \item[--] \textbf{Utilizadores das aplicações;} 
    \item[--]\textbf{Programadores de aplicações} ao definirem o modelo lógico do sistema de informação;
    \item[--] \textbf{DBA} (\textit{Database Administrators}), que concebem e mantêm a base de dados, em termos de desenho físico e lógico, segurança e configuração dos mecanismos de disponibilidade e recuperação. 
\end{itemize}

\chapter{SQL}

\section{Visão Global da Linguagem \textit{Query} SQL}
A linguagem SQL tem várias partes:
\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{\textit{SQL Data-Definition Language (DDL)}}: fornece comandos para definir esquemas relacionais, apagar relações e modificar esquemas relacionais. Inclui ainda comandos para especificação das restrições de integridade que os dados guardados na base de dados devem satisfazer - \textbf{Integridade}, comandos para definir vistas - \textbf{Definição de Vistas}, e comandos para especificar direitos de acesso às relações e vistas - \textbf{Autorização}.
    \item[--]\textbf{\textit{SQL Data-Manipulation Language (DML)}}: fornece a capacidade de consultar informação da base de dados e de inserir em, remover de, e modificar tuplos na base de dados.
    \item[--]\textbf{Controlo de Transações}: o SQL inclui comandos para especificar os pontos iniciais e finais de transações.
    \item[--]\textbf{SQL Embutido e Dinâmico}: SQL embutido é a parte do SQL que é fixo e não pode ser mudado em \textit{run-time}, enquanto que o SQL dinâmico permite acesso à base de dados em \textit{run-time}.
\end{itemize}

\section{Definição de Dados em SQL}
O conjunto de relações numa base de dados são especificados usando uma linguagem \textit{data-definition}. 
O SQL \textit{DDL} permite a especificação de um conjunto de relações, bem como de informação sobre cada relação, incluindo:
\begin{itemize}
    \itemsep0cm
    \item[--]O \textbf{esquema} para cada relação;
    \item[--]Os \textbf{tipos de valores} associados a cada atributo;
    \item[--]As \textbf{restrições de integridade};
    \item[--]O conjunto de \textbf{índices} a manter em cada relação;
    \item[--]A informação de \textbf{segurança} e \textbf{autorização} para cada relação;
    \item[--]A estrutura de \textbf{armazenamento físico} de cada relação em disco.
\end{itemize}

\subsection{Tipos Básicos}
O \textit{standard} SQL suporta uma variedade de tipos, incluindo:
\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{char}(n): uma cadeia de texto de comprimento fixo de $n$;
    \item[--]\textbf{varchar}(n): uma cadeia de texto de comprimento variável até $n$;
    \item[--]\textbf{int}: um inteiro (é equivalente escrever \textbf{integer}) - depende da máquina em que opera, mas geralmente está no intervalo $\interval{-2^{31}}{2^{31} - 1}$;
    \item[--]\textbf{smallint}: um inteiro pequeno - depende da máquina em que opera, mas geralmente está no intervalo $\interval{-2^{15}}{2^{15} - 1}$;
    \item[--]\textbf{numeric}(p, d): um número de vírgula fixa com precisão especificada pelo utilizador - o número consiste de \textbf{p} dígitos (mais o sinal) e \textbf{d} desses \textbf{p} dígitos são à direita da vírgula. \textbf{numeric}(3,1) permite $-44.5$ ser guardado, mas não permite $444.5$, nem $0.32$.
    \item[--]\textbf{real, double precision}: números de vírgula flutuante e número de vírgula flutuante com precisão de \textit{double} - depende da máquina em que opera.
    \item[--]\textbf{float}(n): um número de vírgula flutuante com uma precisão de \textbf{pelo menos} $n$ dígitos.
\end{itemize}

\subsection{Definição Básica de Esquemas}
Definimos uma relação SQL usando o comando \textbf{CREATE TABLE}. O seguinte comando cria a relação \textit{departamento} na base de dados:
\begin{lstlisting}[ language=SQL,
                    deletekeywords={IDENTITY},
                    deletekeywords={[2]INT},
                    morekeywords={clustered},
                    framesep=8pt,
                    xleftmargin=40pt,
                    framexleftmargin=40pt,
                    frame=tb,
                    framerule=0pt ]
CREATE TABLE departamento 
      (nome_dept VARCHAR(20),
       edificio VARCHAR(15),
       orcamento NUMERIC(12, 2)),
       PRIMARY KEY (nome_dept));
\end{lstlisting}
A forma geral do comando \textbf{CREATE TABLE} é:
\begin{lstlisting}[ language=SQL,
                    deletekeywords={IDENTITY},
                    deletekeywords={[2]INT},
                    morekeywords={clustered},
                    framesep=8pt,
                    xleftmargin=40pt,
                    framexleftmargin=40pt,
                    frame=tb,
                    framerule=0pt]
CREATE TABLE r 
      (A_1 D_1,
       A_2 D_2,
       ...,
       A_n D_n,
       <restricao-integridade 1>,
       ...,
       <restricao-integridade k>);
\end{lstlisting}
O SQL suporta uma variedade de \textbf{restrições de integridade}. Algumas delas são:
\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{primary key} ($A_{j_{1}}, A_{j_{2}}, ..., A_{j_{m}}$): esta especificação diz que os atributos $A_{j_{1}}, A_{j_{2}}, ..., A_{j_{m}}$ formam a chave primária da relação - por definição estes devem ser \textbf{NOT NULL} e \textbf{UNIQUE}, i.e., nenhum tuplo pode ter um valor \textbf{null} como atributo de chave primária, e não existem 2 tuplos numa relação com atributos de chave primária iguais. Esta especificação é \textbf{opcional}.
    \item[--]\textbf{foreign key} ($A_{k_{1}}, A_{k_{1}}, ..., A_{k_{n}}$) \textbf{references} \textit{s}: esta especificação diz que os valores dos atributos ($A_{k_{1}},A_{k_{2}}, \\ ..., A_{k_{n}}$) para qualquer tuplo na relação devem corresponder aos atributos de chave primária de algum tuplo da relação \textit{s}.
    \item[--]\textbf{not null}: esta especificação aplica-se a um atributo e especifica que o valor \textbf{null} não é permitido nele, i.e., excluir o valor \textbf{null} do domínio do mesmo.
\end{itemize}
O SQL previne qualquer atualização à base de dados que viole uma restrição de integridade.\\
Para remover uma relação \textit{r} de uma base de dados SQL usamos o comando \textbf{DROP TABLE \textit{r}}, que apaga toda a informação acerca da relação a apagar da base de dados. \\
Para removermos apenas os tuplos contidos numa relação \textit{r} usamos o comando \textbf{DELETE FROM \textit{r}} - de notar que não precisaríamos criar a relação de novo ao usar este comando, a relação apenas ficaria sem qualquer tipo de dados contida nela. \\
Para adicionarmos um atributo \textit{A} de tipo \textit{D} a uma relação \textit{r} usamos o comando \textbf{ALTER TABLE \textit{r} ADD \textit{A} \textit{D}} - de notar que a todos os tuplos é-lhes atribuído \textbf{null} como o valor do novo atributo. \\
Para removermos um atributo \textit{A} de uma relação \textit{r} usamos o comando \textbf{ALTER TABLE \textit{r} DROP \textit{A}}.\\

\section{Estrutura Básica de Consultas SQL}
A estrutura básica de consultas SQL consiste em 3 cláusulas: \textbf{SELECT}, \textbf{FROM} e \textbf{WHERE}. Uma consulta leva como input as relações listadas na cláusula \textbf{FROM}, opera nelas como especificado nas cláusulas \textbf{WHERE} e \textbf{SELECT}, e produz uma relação como resultado. \\
Iremos usar a seguinte base de dados:
\begin{lstlisting}[ language=SQL,
                    deletekeywords={IDENTITY},
                    deletekeywords={[2]INT},
                    morekeywords={clustered},
                    framesep=8pt,
                    xleftmargin=40pt,
                    framexleftmargin=40pt,
                    frame=tb,
                    framerule=0pt]
CREATE TABLE department
    (dept name VARCHAR (20),
    building VARCHAR (15),
    budget NUMERIC (12,2),
    PRIMARY KEY (dept name));
CREATE TABLE course
    (course id VARCHAR (7),
    title VARCHAR (50),
    dept name VARCHAR (20),
    credits NUMERIC (2,0),
    PRIMARY KEY (course id),
    FOREIGN KEY (dept name) REFERENCES department);
CREATE TABLE instructor
    (ID VARCHAR (5),
    name VARCHAR (20) NOT NULL,
    dept name VARCHAR (20),
    salary NUMERIC (8,2),
    PRIMARY KEY (ID),
    FOREIGN KEY (dept name) REFERENCES department);
CREATE TABLE section
    (course id VARCHAR (8),
    sec id VARCHAR (8),
    semester VARCHAR (6),
    year NUMERIC (4,0),
    building VARCHAR (15),
    room number VARCHAR (7),
    time slot id VARCHAR (4),
    PRIMARY KEY (course id, sec id, semester, year),
    FOREIGN KEY (course id) REFERENCES course);
CREATE TABLE teaches
    (ID VARCHAR (5),
    course id VARCHAR (8),
    sec id VARCHAR (8),
    semester VARCHAR (6),
    year NUMERIC (4,0),
    PRIMARY KEY (ID, course id, sec id, semester, year),
    FOREIGN KEY (course id, sec id, semester, year) REFERENCES section,
    FOREIGN KEY (ID) REFERENCES instructor);
\end{lstlisting}

\subsection{Consultas em 1 Relação}
\textbf{1)} Seja a seguinte consulta: "Encontra os nomes de todos os instrutores.". Os nomes dos instrutores podem ser encontrados na relação \textit{instructor}, pelo que pomos isso na cláusula \textbf{FROM}. O nome do instrutor aparece no atributo \textit{name}, colocando isso na cláusula \textbf{SELECT}.

\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT name
FROM instructor;
\end{lstlisting} 
\textbf{2)} Seja a seguinte consulta: "Encontra os nomes de departamento de todos os instrutores.". Dado que mais do que 1 instrutor pode pertencer ao mesmo departamento, o mesmo nome de departamento pode aparecer múltiplas vezes na relação \textit{instructor}. Como tal, interessa-nos forçar a eliminação de duplicados na relação resultante da consulta. Para tal:

\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT DISTINCT dept_name
FROM instructor;
\end{lstlisting}
\textbf{3)} Seja a seguinte consulta: "Como seria a relação de instrutores com um aumento de 10\% no salário?". A cláusula \textbf{SELECT} permite-nos conter expressões aritméticas com os operadores $+, -, *$ e $/$. Logo:

\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT ID, name, dept_name, salary * 1.1
FROM instructor;
\end{lstlisting}
\textbf{4)} Seja a seguinte consulta: "Encontra os names de todos os instrutores no departamento de Engenharia Informática que têm um um salário maior que 2000€.". A cláusula \textbf{WHERE} permite-nos selecionar apenas as linhas (dados da base de dados) na relação resultante da cláusula \textbf{FROM} que satisfazem um predicado especificado. Assim:

\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT name
FROM instructor
WHERE dept_name='Engenharia Informática' AND salary > 2000;
\end{lstlisting}
De notar que o SQL permite o uso de conectores lógicos \textbf{and}, \textbf{or} e \textbf{not} na cláusula \textbf{WHERE}. Os operandos dos conectores lógicos podem ser expressões envolvendo operadores de comparação $<, \leq, >, \geq, =$ e $<>$, permitindo-nos comparar cadeias de caracteres e expressões aritméticas, bem como tipos especiais, como uma data.

\subsection{Consultas em N Relações}
As consultas por vezes precisam de acesso a informação de múltiplas relações. \\
\textbf{1)} Seja a seguinte consulta: "Recolha o nome de todos os instrutores, bem como o seu nome de departamento e o nome do edifício do departamento.". Analisando o esquema da relação \textit{instructor}, percebemos que podemos obter o nome do departamento do atributo \textit{dept\_name}, mas o nome do edifício do departamento está presenta no atributo \textit{building} da relação \textit{department}. Para responder à consulta, cada tuplo na relação \textit{instructor} deve ser correspondida a um tuplo da relação \textit{department} onde os valores \textit{dept\_name} correspondam. Assim, em SQL para respondermos a esta consulta, listamos as relações necessárias na cláusula \textbf{FROM} e especificamos a condição de correspondência de valores de atributos na cláusula \textbf{WHERE}. Assim:

\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT name, instructor.dept_name, building
FROM instructor, department
WHERE instructor.dept_name = department.dept_name;
\end{lstlisting} 
De notar que como o atributo \textit{dept\_name} ocorre em ambas as relações, o prefixo \textit{instructor.dept\_name} é necessário para tornar claro qual o atributo a que nos estamos a referir. Como \textit{name} e \textit{building} só aparecem em 1 das relações não é necessário o seu prefixo.

Podemos assim definir o papel de cada cláusula:
\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{SELECT}: usada para listar os atributos desejados do resultado de uma consulta;
    \item[--]\textbf{FROM}: uma lista de relações a serem acedidas na avaliação da consulta.
    \item[--]\textbf{WHERE}: um predicado que envolve atributos da relação na cláusula \textbf{FROM}.
\end{itemize}

Uma consulta SQL típica tem a seguinte forma:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT A_1, A_2, ..., A_n
FROM r_1, r_2, ..., r_m
WHERE P;
\end{lstlisting}
Cada $A_i$ representa um atributo, cada $r_i$ representa uma relação e $P$ é um predicado - se $P$ for omitido, este é considerado \textbf{true}.

A clásula \textbf{FROM} define um \textbf{produto Cartesiano} entre as relações listadas na cláusula. Pode ser entendido pelo seguinte processo iterativo que gera tuplo para a relação resultante da clásula \textbf{FROM}:
\begin{verbatim}
for each tuple t_1 in relation r_1:
    for each tuple t_2 in relation r_2:
        ...
            for each tuple t_m in relation r_m:
                concatenate t_1, t_2, ..., t_m into a single tuple t
                add t into result relation   
\end{verbatim}

Se quisermos fazer o produto cartesiano entre as relações \textit{instructor} e \textit{teaches}, teremos o seguinte esquema relacional:
\begin{verbatim}
(instructor.ID, instructor.name, instructor.dept_name, instructor.salary,
teaches.ID, teaches.course_id, teaches.sec_id, teaches.semester, teaches.year)
\end{verbatim}
Pelo que simplificando tendo em conta os atributos que só aparecem em 1 das relações:
\begin{verbatim}
(instructor.ID, name, dept_name, salary, teaches.ID, course_id, sec_id, semester, year)
\end{verbatim}
O produto Cartesiano resultante combina tuplos que não têm qualquer tipo de relação entre eles - o resultado pode ser uma relação extremamente grande, e raramente faz sentido criar tal produto Cartesiano.

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.4]{cap_sql/prod_cartesiano.png}
    \caption{Produto cartesiano da relação \textit{instructor} com a relação \textit{teaches}}
\end{figure}

A cláusula \textbf{WHERE} é usada para restringir as combinações criadas pelo produto Cartesiano ao essencial.
\textbf{2)} Seja a seguinte consulta: "Lista todos os instrutores bem como o curso que estes lecionam.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
    SELECT name, course_id
    FROM instructor, teaches
    WHERE instructor.ID = teaches.ID;
\end{lstlisting}

\textbf{3)} Seja a seguinte consulta: "Lista todos os cursos que os instrutores do departamento de Engenharia Informática lecionam.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
    SELECT name, course_id
    FROM instructor, teaches
    WHERE instructor.ID = teaches.ID AND dept_name='Engenharia Informatica';
\end{lstlisting}

Podemos assim generalizar o fluxo de uma consulta SQL como:
\begin{enumerate}[label=\color{blue}\theenumi]
    \item Gerar um produto Cartesiano nas relações listadas na cláusula \textbf{FROM};
    \item Aplicar os predicados especificados na cláusula \textbf{WHERE} como resultado do passo 1;
    \item Para cada tuplo no resultado do passo 2, dar output dos atributos espeficados na cláusula \textbf{SELECT}.
\end{enumerate}

\section{Operações Básicas Adicionais}

\subsection{Operação de Renomeação}
Os nomes dos atributos no resultado de uma consulta derivam dos nomes dos atributos das relações especificadas na cláusula \textbf{FROM}.
Porém, nem sempre podemos derivar nomes desta maneira: duas relações na cláusula \textbf{FROM} podem ter atributos com o mesmo nome; se usarmos uma expressão aritmética na cláusula \textbf{SELECT} o atributo resultante não tem um nome; se um nome de um atributo pode ser derivado diretamente da relação base (por exemplo um nome de atributo presente em apenas 1 relação), podemos querer mudar o nome do atributo no resultado.

A cláusula \textbf{AS} pode aparecer quer nas cláusulas \textbf{SELECT}, quer nas \textbf{FROM}.

\textbf{1)} Se quisermos substituir um nome de atributo por algo mais específico:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT name AS instructor_name, course_id
FROM instructor, teaches
WHERE instructor.ID = teaches.ID;
\end{lstlisting}

\textbf{2)} Seja a seguinte consulta: "Para todos os instrutores na universidade que ensinam um curso, encontra os nomes e o ID do curso que lecionam.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT T.name, S.course_id
FROM instructor AS T, teaches AS S
WHERE T.ID = S.ID;
\end{lstlisting}

\textbf{3)} Seja a seguinte consulta: "Encontra o nome de todos os instrutores cujo salário é maior que pelo menos 1 instrutor no departamento de Biologia.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT DISTINCT T.name,
FROM instructor AS T, instructor AS S
WHERE T.salary > S.salary AND S.dept_name='Biologia';
\end{lstlisting}

No exemplo acima, \textbf{T} e \textbf{S} são consideradas cópias da relação \textit{instructor}, mas mais precisamente, são declarados como \textbf{\textit{alias}}, i.e., nomes alternativas à relação \textit{instructor} - \textbf{T} e \textbf{S} são referidos como \textbf{nomes de correlação} em SQL \textit{standard}, mas também são referidos como \textbf{\textit{table alias}}, \textbf{\textit{correlation variable}} ou \textbf{\textit{tuple variable}}.

\subsection{Operações em Cadeias de Caracteres}

O SQL especifica cadeias de caracteres com aspas singulares, i.e., 'Exemplo'. Para especificarmos uma aspa singular dentro duma cadeia de caracteres devemos usar 'It''s right'.

O SQL \textit{standard} especifica que as operações de igualdade em cadeias de caracteres são sensíveis a maiúsculas/minúsculas.

Permite também uma variedade de funções em cadeias de caracteres, tal como \textbf{concatenação} ($||$), extrair \textit{sub-strings}, encontrar o \textbf{comprimento} de cadeias de caracteres, converter cadeias de caracteres para tudo \textbf{maiúsculo} (\textbf{upper}(s) onde s é uma cadeia de caracteres), \textbf{minúsculo} (\textbf{lower}(s)), remover espaços no fim da cadeia de caracteres (\textbf{trim}(s)), e por aí em diante.

O SQL fornece ainda correspondência de padrões em cadeias de caracteres usando o operador \textbf{LIKE}. Descrevemos padrões usando 2 caracteres especiais:
\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{Percentagem (\%)}: corresponde a qualquer \textit{sub-string};
    \item[--]\textbf{\textit{Underscore} (\_)}: corresponde a qualquer caracter.
\end{itemize}

Alguns exemplos que ilustram a correspondência de padrões em SQL:
\begin{itemize}
    \itemsep0cm
    \item[--]'Intro\%': corresponde a qualquer cadeia de caracteres que começo com "Intro".
    \item[--]'\%Comp\%': corresponde a qualquer cadeia de caracteres que contém "Comp" como \textit{sub-string}, como por exemplo "Intro. to Computer Science" e "Computational Biology".
    \item[--]'\_\_\_': corresponde a uma cadeia de caracteres de exatamente 3 caracteres.
    \item[--]'\_\_\_\%': corresponde a uma cadeia de caracteres de pelo menos 3 caracteres.
\end{itemize}

\textbf{1)} Seja a seguinte consulta: "Encontra os nomes de todos os departamentos cujos edifícios têm o nome 'Watson'". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT dept_name
FROM department
WHERE building LIKE '%Watson%';
\end{lstlisting}

O SQL permite o uso de um caracter \textit{escape} que antecede qualquer caracter especial de padrões para indicar que o caracter especial de padrões está a ser tratado como um caracter normal - para tal usamos a palavra-chave \textbf{ESCAPE}:
\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{LIKE} 'ab\textbackslash\%cd\%' ESCAPE '\textbackslash': corresponde a todas as cadeias de caracteres que começam com "ab\%cd".
    \item[--]\textbf{LIKE} 'ab\textbackslash \textbackslash cd\%' ESCAPE '\textbackslash': corresponde a todas as cadeias de caracteres que começam com "ab\textbackslash cd".
\end{itemize}

\subsection{Especificação de Atributo na cláusula SELECT}
O símbolo do asterisco (\textbf{*}) pode ser usado na cláusula \textbf{SELECT} para denotar todos os atributos. Podemos especificar então uma consulta com 2 relações em que queiramos todos os atributos de apenas 1 das relações da seguinte maneira:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT instructor.*
FROM instructor, teaches
WHERE instructor.ID = teaches.ID;
\end{lstlisting}

\subsection{Ordenação da Disposição dos Tuplos}
O SQL oferece ao utilizador algum controlo sobre a ordem na qual os tuplos numa relação são dispostos - a cláusula \textbf{ORDER BY} causa os tuplos no resultado da query a seguirem uma dada relação de ordenação. 

\textbf{1)} Seja a seguinte consulta: "Liste todos os instrutores que trabalham no Departamento de Física por ordem alfabética.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT name
FROM instructor
WHERE dept_name = 'Física'
ORDER BY name;
\end{lstlisting}

Se tivermos vários nomes de atributos na cláusula \textbf{ORDER BY} este segue o primeiro como principal critério de ordenação e os subsequentes como critério de desempate.

\textbf{2)} Seja a seguinte consulta: "Liste a relação \textit{instructor} por ordem descendente de salário, e em caso de empate, por ordem alfabética.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT *
FROM instructor
ORDER BY salary DESC, name ASC;
\end{lstlisting}

\subsection{Predicados da cláusula WHERE}
O SQL inclui um operador \textbf{BETWEEN} para simplificar enquadramentos de valores.

\textbf{1)} Seja a seguinte consulta: "Liste todos os instrutores cujos salários estão entre 2000€ e 3000€.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT name
FROM instructor
WHERE salary BETWEEN 2000 AND 3000;
\end{lstlisting}

Similarmente, podemos usar o operador de comparação \textbf{NOT BETWEEN}.

O SQL permite-nos ainda usar a notação ($v_{1}, v_{2}, ..., v_{n}$) para denotar um tuplo de aridade $n$ contendo os valores $v_1, v_2, ..., v_n$ - esta notação é designada \textbf{\textit{row constructor}}. Por exemplo, $(a_1, a_2) \leq (b_1, b_2)$ só é verdade sse $a_1 \leq b_1$ e $a_2 \leq b_2$.

Podemos então reescrever este query
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT name, course_id
FROM instructor, teaches
WHERE instructor.ID = teaches.ID AND dept_name = 'Biologia';
\end{lstlisting}
usando a notação do \textbf{\textit{row constructor}}:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT name, course_id
FROM instructor, teaches
WHERE (instructor.ID, dept_name) = (teaches.ID, 'Biologia');
\end{lstlisting}

\subsection{Operações de Conjuntos}
As operações SQL \textbf{union}, \textbf{intersect} e \textbf{except} operam em relações e correspondem às operações matemáticas de conjuntos $\cup, \cap$ e $-$.

\subsubsection{Operador de União}
\textbf{1)} Seja a seguinte consulta: "Selecione todos os ID's de cursos lecionados no 2º semestre do ano de 2017 e 1ºsemestre do ano de 2018.". Podemos decompor isto:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- O conjunto de cursos lecionados no 2 semestre de 2017
SELECT course_id
FROM section
WHERE semester=2 AND year=2017;

-- O conjunto de cursos lecionados no 1 semestre de 2018
SELECT course_id
FROM section
WHERE semester=1 AND year=2018;

-- A uniao destes da-nos o resultado da consulta (sem duplicados)
(SELECT course_id
FROM section
WHERE semester=2 AND year=2017)
UNION
(SELECT course_id
FROM section
WHERE semester=1 AND year=2018);

-- A uniao destes da-nos o resultado da consulta (com duplicados)
(SELECT course_id
FROM section
WHERE semester=2 AND year=2017)
UNION ALL
(SELECT course_id
FROM section
WHERE semester=1 AND year=2018);
\end{lstlisting}

De notar que o operador \textbf{UNION} elimina automaticamente os duplicados, pelo que se os quisermos manter deve suceder ao operador a palavra-chave \textbf{ALL}.

\subsubsection{Operador de Interseção e de Exceção}
Os operadores de interseção e exceção são semanticamente iguais ao da união, pelo que o código acima pode ser reutilizado substituindo apenas a palavra-chave \textbf{UNION} por \textbf{INTERSECT} ou \textbf{EXCEPT} (o \textbf{ALL} tem o mesmo propósito para todos os operadores), mediante o propósito da consulta.

\section{Valores NULL}
Os \textbf{valores NULL} apresentam problemas nas operações relacionais, incluindo operações aritméticas, de comparação e de conjuntos.

O resultado de uma expressão aritmética em que um dos valores de \textit{input} é NULL, é também NULL (exemplo: $r.A + 5$ onde $r.A$ é null para um tuplo em particular - a expressão resultante é também null para esse tuplo).

O resultado de uma operação de comparação é \textbf{unknown} sempre que um dos valores de \textit{input} é null.

Os predicados nas cláusulas \textbf{WHERE} envolvem operações Booleanas como \textbf{AND}, \textbf{OR} e \textbf{NOT}. Estes estão prontos para lidar com o valor \textbf{unknown} da seguinte forma:
\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{AND}: O resultado de \textit{true} \textbf{AND} \textit{unknown} é \textit{unknown} e \textit{false} \textbf{AND} \textit{unknown} é \textit{false}, enquanto que \textit{unknown} \textbf{AND} \textit{unknown} é \textit{unknown}.
    \item[--]\textbf{OR}: O resultado de \textit{true} \textbf{OR} \textit{unknown} é \textit{true} e \textit{false} \textbf{OR} \textit{unknown} é \textit{unknown}, enquanto que \textit{unknown} \textbf{OR} \textit{unknown} é \textit{unknown}.
    \item[--]\textbf{NOT}: O resultado de \textbf{NOT} \textit{unknown} é \textit{unknown}.
\end{itemize}

Se o predicado da cláusula \textbf{WHERE} avalia a \textbf{false} ou \textbf{unknown} para um tuploe, este não é adicionado ao resultado.

O SQL usa a palavra-especial \textbf{NULL} num predicado para testar para um valor null.

\textbf{1)} Seja a seguinte consulta: "Liste todos os instrutores que não têm um salário especificado.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT name
FROM instructor
WHERE salary IS NULL;
\end{lstlisting}

De notar que o salário não pode ser comparado em igualdade a um valor nulo, isto é, não poderíamos ter $salary = NULL$, e como tal, usamos a palavra-chave \textbf{IS}.

\section{Funções de Agregação}
As \textbf{funções de agregação} são funções que tomam uma coleção de valores como \textit{input} e retornam um único valor. O SQL oferece 5 funções de agregação:
\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{Média}: $AVG$ (requer que a coleção seja unicamente composta de números)
    \item[--]\textbf{Mínimo}: $MIN$
    \item[--]\textbf{Máximo}: $MAX$
    \item[--]\textbf{Total}: $SUM$ (requer que a coleção seja unicamente composta de números)
    \item[--]\textbf{Contagem}: $COUNT$
\end{itemize}

\subsection{Agregação Básica}
\textbf{1)} Seja a seguinte consulta: "Encontra o salário médio dos instrutores no departamento de Engenharia Informática.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT AVG(salary)
FROM instructor
WHERE dept_name='Engenharia Informatica';

-- Porem, queremos dar um nome com significado ao resultado do SELECT
SELECT AVG(salary) AS avg_salary
FROM instructor
WHERE dept_name='Engenharia Informatica';
\end{lstlisting}

\textbf{2)} Seja a seguinte consulta: "Encontra o número total de instrutores que lecionaram um curso no 1º semestre de 2018.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- O DISTINCT aqui permite que um instrutor tenha lecionado mais que 1 curso, mas ser contado apenas 1 vez
SELECT COUNT(DISTINCT id)
FROM teaches
WHERE semester = 1 AND year = 2018;
\end{lstlisting}

\textbf{3)} Seja a seguinte consulta: "Quantas entradas estão na relação \textit{course}?". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT COUNT(*)
FROM course;
\end{lstlisting}
De notar que o SQL não permite o use da palavra-chave \textbf{DISTINCT} com a função de agregação \textbf{COUNT(*)}.

\subsection{Agregação com Agrupamento}
Existem circunstâncias em que queremos aplicar a função de agregação não só a um único conjunto de tuplo, mas também a grupos de conjuntos de tuplos - especificamos isto em SQL usando a cláusula \textbf{GROUP BY}. 

Os atributos dados na cláusula \textbf{GROUP BY} são usados para formar grupos. Tuplos com o mesmo valor em todos os atributos na cláusula \textbf{GROUP BY} são postos num grupo.
\textbf{1)} Seja a seguinte consulta: "Encontra o salário médio para cada departamento.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT dept_name, AVG(salary) AS avg_salary
FROM instructor
GROUP by dept_name;
\end{lstlisting}

\textbf{2)} Seja a seguinte consulta: "Encontra o número de instrutores em cada departamento que lecionaram um curso no 1º semestre de 2018.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT dept_name, COUNT(DISTINCT id) AS instr_count
FROM instructor, teaches
WHERE (instructor.ID, semester, year) = (teaches.ID, 1, 2018)
GROUP BY dept_name;
\end{lstlisting}

É importante ao usar agrupamento em consultas SQL assegurar que os únicos atributos que aparecem no cláusula \textbf{SELECT}, e que não são as que estão a ser agregadas, estão presentes na cláusula \textbf{GROUP BY}.

\subsection{Cláusula HAVING}
Quando queremos aplicar condições que se aplicam a \textbf{grupos} e não tuplos, usamos a cláusula \textbf{HAVING}. Recordemos que os grupos são formados através da cláusula \textbf{GROUP BY}.

\textbf{1)} Seja a seguinte consulta: "Encontra o salário médio dos instrutores nos departamentos cujo salário médio é maior que 2500€.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT dept_name, AVG(salary) AS avg_salary
FROM instructor
GROUP BY dept_name
HAVING AVG(salary) > 42000;
\end{lstlisting}
É importantíssimo notar que o SQL aplica os predicados na cláusula \textbf{HAVING} \textbf{após os grupos se formarem}, pelo que funções de agregação podem ser usadas na cláusula \textbf{HAVING}.

\textbf{2)} Seja a seguinte consulta: "Para cada curso oferecido em 2017, encontra a média de créditos totais (tot\_cred) de todos os estudantes inscritos na secção, se a secção tem pelo menos 2 estudantes.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT course_id, semester, year, sec_id, AVG(tot_cred)
FROM student, takes
WHERE (student.ID, year) = (takes.ID, 2017)
GROUP BY course_id, semester, year, sec_id
HAVING COUNT(ID) >= 2;
\end{lstlisting}

\subsection{Agregação com Valores NULL e Booleanos}
As funções de agregação tratam o valor null do seguinte modo: todas as funções de agregação exceto o \textbf{COUNT (*)} ignoram valores null para a coleção de input. Como resultado de ignorar null values, a coleção de valores pode ser vazia. O \textbf{COUNT} de uma coleção vazia é definido como 0, e todas as outras operações de agregação retorna o valor de null quando aplicado numa coleção vazia.

O tipo de dados Booleano pode assumir valores \textbf{true}, \textbf{false} e \textbf{unknown}. As funções de agregação \textbf{SOME} e \textbf{ALL} podem ser aplicadas a uma coleção de valores Booleanos, e computar a disjunção (\textbf{OR}) e a conjunção (\textbf{AND}), respetivamente, dos valores.

\section{Sub-Consultas Aninhadas}
O SQL fornece um mecanismo de aninhamento de sub-consultas.
\begin{definition}[Sub-Consulta]
    Uma sub-consulta é uma expressão \textbf{SELECT-FROM-WHERE} que está aninhada noutra consulta.
\end{definition}
As sub-consultas são geralmente usadas para executar testes em pertença de conjuntos, comparações entre conjuntos e determinação de cardinalidade de conjuntos.

\subsection{Pertença de Conjuntos}
O SQL permite testar pertença de tuplos numa relação. O conector de palavra-chave \textbf{IN} testa por pertença de conjuntos, onde o conjunto é uma coleção de valores produzida pela cláusula \textbf{SELECT}. O conector \textbf{NOT IN} testa a abstenção de pertença.

\textbf{1)} Seja de novo a seguinte consulta: "Selecione todos os ID's de cursos lecionados no 2º semestre do ano de 2017 e 1ºsemestre do ano de 2018.". Podemos reescrever a consulta do seguinte modo:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT DISTINCT course_id
FROM section
WHERE semester=2 AND year=2017 AND
    course_id IN (SELECT course_id
                  FROM section
                  WHERE semester=1 AND year=2018);
\end{lstlisting}

De notar que os operadores \textbf{IN} e \textbf{NOT IN} podem também ser usados em conjuntos enumerados. Por exemplo, \\
\textbf{2)} Seja a seguinte consulta: "Encontra o nome de todos os instrutores cujo nome não é "Mozart" nem "Einstein"". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT DISTINCT name
FROM instructor
WHERE name NOT IN ('Mozart', 'Einstein');
\end{lstlisting}

\subsection{Comparação de Conjuntos}
\textbf{1)} Seja de novo a seguinte consulta: "Encontra o nome de todos os instrutores cujo salário é maior que pelo menos 1 instrutor no departamento de Biologia.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT name
FROM instructor 
WHERE salary > SOME (SELECT salary
                     FROM instructor
                     WHERE dept_name='Biologia');
\end{lstlisting}

O operador $> SOME$ na cláusula \textbf{WHERE} no \textbf{SELECT} exterior é verdadeiro se o valor de \textit{salary} do tuplo é maior que pelo menos um membro do conjunto de todos os valores de salários de instrutores em Biologia.

\textbf{2)} Seja a seguinte consulta: "Encontra o nome de todos os instrutores que têm um salário maior do que todos os instrutores no departamento de Biologia.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT name
FROM instructor 
WHERE salary > ALL (SELECT salary
                     FROM instructor
                     WHERE dept_name='Biologia');
\end{lstlisting}

\textbf{3)} Seja a seguinte consulta: "Encontra os departamentos que têm o maior salário médio.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT dept_name
FROM instructor 
GROUP BY dept_name
HAVING AVG(salary) >= ALL (SELECT AVG(salary)
                           FROM instructor
                           GROUP BY dept_name);
\end{lstlisting}

\subsection{Teste para Relações Vazias}
O SQL inclui um elemento para testar se uma sub-consulta tem algum tuplo no seu resultado - palavra-chave \textbf{EXISTS}. É um booleano que retorna o valor \textbf{true} se a sub-consulta de argumento não é vazia.

\textbf{1)} Seja de novo a seguinte consulta: "Selecione todos os ID's de cursos lecionados no 2º semestre do ano de 2017 e 1ºsemestre do ano de 2018.". Temos agora:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT course_id
FROM section AS S 
WHERE semester=2 AND year=2017 AND
    EXISTS (SELECT *
            FROM section AS T
            WHERE semester=1 AND year=2018 and S.course_id = T.course_id);
\end{lstlisting}
Isto é a primeira vez que uma consulta ilustra o funcionamento de um \textbf{nome de correlação} de uma consulta externa (\textbf{S}) é usado numa sub-consulta na cláusula \textbf{WHERE}. Uma sub-consulta que usa o nome de correlação de uma consulta externa é chamada uma \textbf{sub-consulta correlacionada}.

\textbf{2)} Seja a seguinte consulta: "Encontra todos os alunos que tiraram cursos oferecidos pelo departamento de Biologia.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT S.ID, S.name
FROM student AS S 
WHERE NOT EXISTS ((SELECT course_id
                   FROM course
                   WHERE dept_name='Biologia'
                   EXCEPT
                   (SELECT T.course_id
                   from takes AS T
                   WHERE S.ID=T.ID));
-- Retorna o conjunto de cursos oferecidos pelo departamento de Biologia
SELECT course_id
FROM course
WHERE dept_name='Biologia'

-- Retorna o conjunto de cursos que o estudante S.ID já tirou
SELECT T.course_id
FROM takes AS T
WHERE S.ID=T.ID
\end{lstlisting}

\subsection{Teste para Ausência de Tuplos Duplicados}
O SQL inclui uma função Booleana para testar se uma sub-consulta tem tuplos duplicados no seu resultado - o construtor \textbf{UNIQUE} retorna o valor \textbf{true} se a sub-consulta não contém tuplos duplicados.

\textbf{1)} Seja a seguinte consulta: "Encontra todos os cursos que foram oferecidos no máximo 1 vez em 2017.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT T.course_id
FROM course AS T
WHERE UNIQUE (SELECT R.course_id
              FROM section AS R
              where T.course_id = R.course_id AND R.year=2017);
              
-- Equivalentemente podemos usar o COUNT
SELECT T.course_id
FROM course AS T
WHERE 1 >= (SELECT COUNT(R.course_id)
              FROM section AS R
              where T.course_id = R.course_id AND R.year=2017);
\end{lstlisting}

\subsection{Sub-Consultas na cláusula FROM}
O SQL permite uma sub-consulta ser usada como expressão na cláusula \textbf{FROM}. O conceito-chave aplicado aqui é que a expressão \textbf{SELECT-FROM-WHERE} retorna uma relação como resultado, e, como tal, pode ser inserido noutro \textbf{SELECT-FROM-WHERE} em qualquer lado que uma relação possa aparecer.

\textbf{1)} Seja a seguinte consulta: "Encontra o salário médio dos instrutores cujos departamentos têm um salário médio maior que 2500€.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT dept_name, avg_salary
FROM (SELECT dept_name, AVG(salary) as avg_salary
      FROM instructor
      GROUP BY dept_name) AS dept_avg (dept_name, avg_salary)
WHERE avg_salary > 42000;
\end{lstlisting}

De notar que no \textit{PostgreSQL} (SGBD da cadeira) é necessário que cada relação de sub-consulta numa cláusula \textbf{FROM} lhe seja atribuído um nome, mesmo que nunca seja referenciado - neste caso usámos o identificador \textbf{dept\_avg}.

\textbf{2)} Seja a seguinte consulta: "Encontra o máximo de salário que cada departamento com todos os seus instrutores tem.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT MAX(tot_salary)
FROM (SELECT dept_name, SUM(salary)
      FROM instructor
      GROUP BY dept_name) AS dept_avg (dept_name, tot_salary);
\end{lstlisting}

\subsection{Claúsula WITH}
A cláusula \textbf{WITH} fornece uma maneira de definir temporariamente uma relação cuja definição só está disponível à consulta na qual a cláusula \textbf{WITH} ocorre.

\textbf{1)} Seja a seguinte consulta: "Encontra os departamentos com maior salário.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
WITH max_budget(value) AS
    (SELECT MAX(budget)
     FROM departament)
SELECT budget
FROM department, max_budget
WHERE department.budget = max_budget.value;
\end{lstlisting}

\textbf{2)} Seja a seguinte consulta: "Encontra os departamentos cujo salário total é maior do que a média de salário total em todos os departamentos.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
WITH dept_total(dept_name, value) AS
    (SELECT dept_name, SUM(salary)
     FROM instructor
     GROUP BY dept_name),
     dept_total_avg(value) AS 
    (SELECT AVG(value)
     FROM dept_total)
SELECT dept_name
FROM dept_total, dept_total_avg
WHERE dept_total.value > dept_total_avg.value;
\end{lstlisting}

\subsection{Sub-Consultas Escalares}
O SQL permite que sub-consultas ocorram sempre que uma expressão que retorna um valor é permitida, desde que a sub-consulta retorna apenas um tuplo contendo um único atributo - tais sub-consultas são designadas \textbf{sub-consultas escalares}.

\textbf{1)} Seja a seguinte consulta: "Lista todos os departamentos bem como o número de instrutores em cada departamento.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT dept_name, 
       (SELECT COUNT(*)
        FROM instructor
        WHERE department.dept_name=instructor.dept_name) AS num_instructors
FROM department;
\end{lstlisting}

\section{Modificação da Base de Dados}
Vejamos agora como adicionar, remover ou mudar informação com o SQL.

\subsection{Remoção}
Um pedido \textbf{DELETE} é expresso da mesma maneira que uma consulta - só podemos \textbf{apagar tuplos}; não podemos apagar valores de certos atributos apenas. SQL expressa uma remoção por:

\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
DELETE FROM r
WHERE P;
\end{lstlisting}
onde \textbf{P} é um predicado e \textbf{r} representa uma relação.

O \textbf{DELETE} procura primeiro todos os tuplos \textit{t} em \textbf{r} tal que \textbf{\textit{P(t)}} seja verdadeiro, e depois remove-os de \textbf{r}. Se o predicado \textbf{P} for omitido, remove todos os tuplos da relação \textbf{r}.

\textbf{1)} Seja a seguinte operação: "Apague todos os tuplos na relação \textit{instructor} cujo edifício do respetivo departamento contém Watson no nome.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
DELETE FROM instructor
WHERE dept_name IN (SELECT dept_name
                    FROM department
                    WHERE building LIKE '%Watson%');
\end{lstlisting}

\subsection{Inserção}
Para inserir dados numa relação, ou especificamos o tuplo a ser inserido ou escrevemos uma consulta cujo resultado é um conjunto de tuplos a serem inseridos.

\textbf{1)} Seja a seguinte operação: "Insira um novo curso de ID EI-437 no departamento de Engenharia Informática com título "Sistemas de Bases de Dados" e 4 horas de crédito. Escrevemos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
INSERT INTO course
       VALUES ('EI-437', 'Sistemas de Bases de Dados', 'Engenharia Informatica', 4);
\end{lstlisting}

\textbf{2)} Seja a seguinte operação: "Faça cada estudante no departamento de Música que já tenha ganho 144 horas de crédito um instrutor no departamento de Música com um salário de 800€.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
INSERT INTO instructor
       SELECT ID, name, dept_name, 18000
       FROM student
       WHERE dept_name='Musica' AND tot_cred > 144;
\end{lstlisting}

\subsection{Atualizações}
Em certas situações, podemos querer mudar o valor de um tuplo sem mudar \textbf{todos} os valores nesse mesmo. Para tal, usamos o \textbf{STATEMENT}.

\textbf{1)} Seja a seguinte operação: "Faça cada instrutor ter um aumento de 5\% no seu salário.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
UPDATE instructor
SET salary = salary * 1.05

-- Um tweak seria atualizar o salario apenas para quem recebe menos de 1000 pau
UPDATE instructor
SET salary = salary * 1.05
WHERE salary < 1000;

-- Outro tweak seria atualizar o salario apenas a quem esta abaixo da media
UPDATE instructor
SET salary = salary * 1.05
WHERE salary < (SELECT AVG(salary)
                FROM instructor);

-- Por fim um tweak cuja ORDEM IMPORTA seria
UPDATE instructor
SET salary = salary * 1.03
WHERE salary > 1000;

UPDATE instructor
SET salary = salary * 1.05
WHERE salary <= 1000;
\end{lstlisting}

Como vimos, no último \textit{tweak} a ordem era relevante. Para facilitar a vida do programador, o SQL fornece um construtor \textbf{CASE} para executar ambas as atualizações num único \textbf{UPDATE}:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
UPDATE instructor
SET salary = CASE
                WHEN salary <= 1000 THEN salary * 1.05
                ELSE salary * 1.03
             END

-- A forma geral do CASE eh dada por
             CASE
                WHEN pred_1 THEN res_1
                WHEN pred_2 THEN res_2
                ...
                WHEN pred_n THEN res_n
                ELSE res_0
             END
\end{lstlisting}

\section{Expressões JOIN}
Até agora, usámos o produto Cartesiano para combinar informação de múltiplas relações. O operador \textbf{JOIN} permite escrever consultas com múltiplas relações de um modo mais natural.

\subsection{Natural JOIN} 
A operação de \textbf{NATURAL JOIN} opera em 2 relações e produz uma relação como resultado. Considera apenas os pares de tuplos com o mesmo valor nos atributos que aparecem nos esquemas de ambos. \\
Assim, \\
\textbf{1)} Seja a seguinte consulta: "Para todos os estudantes na universidade que tiraram um curso, descobre o nome e o ID do curso que tiraram.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Antes do JOIN
SELECT name, course_id
FROM student, takes
WHERE student.ID = takes.ID

-- Com Natural JOIN
SELECT name, course_id
FROM student NATURAL JOIN takes

-- AMBAS AS QUERIES GERAM O MESMO RESULTADO
\end{lstlisting}

De notar que o que realmente está a acontecer ao fazer \textbf{NATURAL JOIN} é que se estão a considerar apenas os pares de tuplos onde quer o tuplo de \textit{student}, quer o tuplo de \textit{takes} têm o mesmo valor no atributo comum, \textbf{ID}.

O resultado de uma operação de \textbf{NATURAL JOIN} é uma relação. Uma cláusula \textbf{FROM} de uma consulta SQL pode ter múltiplas relações combinadas usando o \textbf{NATURAL JOIN}. A consulta SQL na sua forma geral usando \textbf{NATURAL JOIN}'s é dada por:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT A_1, A_2, ..., A_n
FROM E_1, E_2, ..., E_m
WHERE P;
\end{lstlisting}

Por sua vez, cada $E_i$ pode ser uma única relação ou uma expressão envolvendo \textbf{NATURAL JOIN}'s.

\textbf{1)} Seja a seguinte consulta: "Lista os nomes dos estudantes bem como o título dos cursos que já tiraram.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Exemplificacao da formula geral (primeiro faz o NATURAL JOIN, so depois o produto cartesiano)
SELECT name, title
FROM student NATURAL JOIN takes, course
WHERE takes.course_id = course.course_id;
\end{lstlisting}

De notar que não podemos fazer um duplo \textbf{NATURAL JOIN}, pois necessitaríamos que os valores dos atributos \textit{dept\_name} e \textit{course\_id} fossem iguais, quando só queremos juntar o \textit{course\_id}. 

Para tal, o SQL fornece a operação \textbf{JOIN \dots USING} que leva no \textbf{USING} uma lista de nomes de atributos a serem especificados. Ou seja, se tivéssemos 
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
r_1 JOIN r_2 USING (A_1, A_2)
\end{lstlisting}
seria semelhante a 
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
r_1 NATURAL JOIN r_2
\end{lstlisting}
porém um par de tuplos no primeiro caso corresponde se $t_1.A_1 = t_2.A_1$ e $t_1.A_2 = t_2.A_2$, e mesmo que se tivessem ambos um terceiro atributo $A_3$, não seria necessário $t_1.A_3 = t_2.A_3$, enquanto que no segundo caso já seria.

\subsection{Condições JOIN}
O SQL suporta outra forma de \textbf{JOIN}, no qual uma condição arbitrária pode ser especificada com a palavra-chave \textbf{ON}. Esta palavra-chave recebe um predicado geral sobre as relações a serem \textbf{JOIN}ed e aparece no fim da expressão \textbf{JOIN}.

\textbf{0)} Seja a seguinte consulta:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT *
FROM student JOIN takes ON student.ID = takes.ID;

-- Equivalente a
SELECT *
FROM student, takes
WHERE student.ID = takes.ID;
\end{lstlisting}

De notar que o que difere isto de um \textbf{NATURAL JOIN} é que a relação resultante tem o atributo ID listado 2 vezes, 1 para \textit{student} e outro para \textit{takes}, apesar dos seus valores terem de ser o mesmo.
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Alternativa ao problema supramencionado
SELECT student.ID as ID, name, dept_name, tot_cred, 
       course_id, sec_id, semester, year, grade
FROM student JOIN takes ON student.ID = takes.ID;
\end{lstlisting}

\subsection{Outer JOIN}
A operação \textbf{OUTER JOIN} funciona de forma similar às que já vimos, mas preserva os tuplos que seriam perdidos num \textbf{JOIN} ao criar tuplos no resultado que contêm \textbf{valores null}. É importante referir que quer o \textbf{NATURAL JOIN}, quer o \textbf{JOIN \dots ON} não conseguiriam corresponder um valor null a outro não null.

Existem 3 formas de \textbf{OUTER JOIN} (consideremos \textbf{A $<$keyword$>$ OUTER JOIN B}):
\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{LEFT OUTER JOIN}: preserva os tuplos apenas da relação A;
    \item[--]\textbf{RIGHT OUTER JOIN}: preserva os tuplos apenas da relação B;
    \item[--]\textbf{FULL OUTER JOIN}: preserva os tuplos das relações A e B;
\end{itemize}

Em contraste, as operações \textbf{JOIN \dots USING}, \textbf{NATURAL JOIN} e \textbf{JOIN \dots ON P} são chamadas operações \textbf{INNER JOIN}.

A operação de \textbf{LEFT OUTER JOIN} opera do seguinte modo:
\begin{verbatim}
res = A NATURAL JOIN B
for each tuple r in A that doesn't match with B:
    r->derived_from_A = r->derived_from_A
    (r->derived_from_B \ r->derived_from_A) = null
    // considera-se r = r->derived_from_A U r->derived_from_B
    res += {r}
\end{verbatim}

Se considerarmos um estudante que nunca tenha tirado um curso, podemos agora listar todos os estudantes e os seus cursos (mesmo que ainda não tenham tirado um), do seguinte modo:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT *
FROM student NATURAL LEFT OUTER JOIN takes;
\end{lstlisting}

\textbf{1)} Seja a seguinte consulta: "Encontra todos os alunos que ainda não tiraram um curso.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Usando LEFT OUTER JOIN
SELECT ID
FROM student NATURAL LEFT OUTER JOIN takes
WHERE course_id IS NULL;

-- Usando RIGHT OUTER JOIN (simetrico)
SELECT ID
FROM takes NATURAL RIGHT OUTER JOIN student
WHERE course_id IS NULL;
\end{lstlisting}

O \textbf{FULL OUTER JOIN} é uma combinação de \textbf{LEFT OUTER JOIN} e \textbf{RIGHT OUTER JOIN}. Depois de computar o resultado do \textbf{INNER JOIN}, extende com \textbf{nulls} os tuplos do lado esquerdo da relação que não corresponderam com nenhum do lado direito da relação, e vice-versa. Por outras palavras, \textbf{FULL OUTER JOIN} = \textbf{LEFT OUTER JOIN} $\cup$ \textbf{RIGHT OUTER JOIN}.

\textbf{2)} Seja a seguinte consulta: "Exiba uma lista de todos os estudantes no departamento de Engenharia Informática, bem como as secções de curso, se alguma, que ocorreram no 2º semestre de 2017; todas as secções de curso do 2º semestre de 2017 devem ser dispostas, mesmo que nenhum estudante de Engenharia Informática tenha tirado a secção do curso.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT *
FROM (SELECT *
      FROM STUDENT
      WHERE dept_name='Engenharia Informatica')
      NATURAL FULL OUTER JOIN
      (SELECT * 
       FROM TAKES
       WHERE semester=2 AND year=2017);
\end{lstlisting}

A cláusula \textbf{ON} pode ser usada com \textbf{OUTER JOIN}'s. É importante notar que este difere do modo como a cláusula \textbf{WHERE} opera, ao contrário dos \textbf{INNER JOIN}.
Ou seja,
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- LEFT OUTER JOIN (ON)
SELECT *
FROM student LEFT OUTER JOIN takes ON student.ID = takes.ID;

-- LEFT OUTER JOIN (WHERE)
SELECT *
FROM student LEFT OUTER JOIN takes ON true
WHERE student.ID = takes.ID
\end{lstlisting}

O caso do \textbf{ON} tem um tuplo com estudantes que ainda não tenham tirado nenhum curso. No caso do \textbf{WHERE}, o \textit{takes ON true} faz com que o \textbf{LEFT OUTER JOIN} se comporte como um produto Cartesiano das 2 relações. Seja um estudante que ainda não tenha tirado um curso com ID = 69. A cláusula \textbf{WHERE} não irá encontrar nenhuma correspondência entre \textit{student}.ID e \textit{takes}.ID, pois não existe nenhum tuplo em \textit{takes} com ID = 69.

\subsection{Tipos e Condições de JOIN}
Para distinguir \textbf{JOIN}'s normais de \textbf{OUTER JOIN}'s, os \textbf{JOIN}'s normais são designados \textbf{INNER JOIN}'s em SQL.

Uma cláusula de \textbf{JOIN} pode ser usada para especificar \textbf{INNER JOIN} em vez de \textbf{OUTER JOIN} para espeficar que se quer um \textbf{JOIN} normal. Contudo, a palavra-chave \textbf{INNER} é opcional, pois por defeito, a cláusula \textbf{JOIN} efetua um \textbf{INNER JOIN} ou \textbf{JOIN} normal, ou seja,

\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- JOIN
SELECT *
FROM student JOIN takes USING (id);

-- INNER JOIN
SELECT *
FROM student INNER JOIN takes USING (id);
\end{lstlisting}
estas 2 consultas são absolutamente equivalentes.

Eis uma lista que mostra que os vários tipos de \textbf{JOIN} (\textbf{INNER}, \textbf{LEFT OUTER}, \textbf{RIGHT OUTER} e \textbf{FULL OUTER}) podem ser combinados com qualquer condição de \textbf{JOIN} (\textbf{NATURAL}, \textbf{USING} ou \textbf{ON}).

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.5]{cap_sql/join_tipos_conds.png}
    \caption{Tipos e Condições de \textbf{JOIN}}
\end{figure}

Por fim, deixo uma nota sobre o \textbf{CROSS JOIN}. Estas 2 consultas são equivalentes:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT *
FROM student, takes;

-- equivalente a

SELECT *
FROM student CROSS JOIN takes;
\end{lstlisting}

\section{Vistas}
Podemos querer criar uma coleção personalizade de relações "virtuais"\footnote{Diz-se virtual pois as vistas mapeiam dados das tabelas do \textbf{modelo físico} para um novo \textbf{modelo lógico}, havendo independência lógica entre estes 2 modelos.} que melhor se adequam a uma certa intuição do utilizador sobre a estrutura da organização. No exemplo da universidade, podemos querer listar todos as secções de curso oferecidas pelo departamento de Física no 2º semestre do ano de 2016, com o edifício e número de sala de cada secção. A consulta correspondente seria:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT course.course_id, sec_id, building, room_number
FROM course, section
WHERE course.course_id = section.course_id
    AND course.dept_name = 'Fisica'
    AND section.semester = 2
    AND section.year = 2017;
\end{lstlisting}
É possível computar e guardar os valores destas consultas e torná-las disponíveis aos utilizadores. Porém, se algum dos valores em \textit{instructor}, \textit{course} ou \textit{section} mudarem, os valores consultados guardados não correspondem à realidade.

Assim, o SQL permite uma "relação virtual" ser definida por uma consulta, e esta mesmo relação conceptual contém o resultado da consulta - a consulta é computada sempre que a relação virtual é usada. Já vimos algo semelhante com a clásula \textbf{WITH}, que nos permite nomear uma sub-consulta para uma consulta apenas. A \textbf{VIEW} permite estender o conceito de relação virtual para além de uma única consulta.

\subsection{Definição de Vista}
Definimos uma vista em SQL usando o comando \textbf{CREATE VIEW}. Para definir a vista devemos nomeá-la e definir qual a consulta que a computa.
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE VIEW v AS <expressao da consulta>;
\end{lstlisting}

Para a remover da base de dados, é igual a qualquer outro objeto de uma base de dados:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
DROP VIEW v;
\end{lstlisting}

Considerando a consulta que foi apresentada no início do sub-capítulo, podemos definir uma vista sobre essa consulta.
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE VIEW fisica_1semestre_2017 AS
    SELECT course.course_id, sec_id, building, room_number
    FROM course, section
    WHERE course.course_id = section.course_id
        AND course.dept_name = 'Fisica'
        AND section.semester = 2
        AND section.year = 2017;
\end{lstlisting}

\subsection{Vistas em Consultas SQL}
Uma vez definida uma vista, podemos usar o nome que lhe foi atribuída para nos referirmos à relação que a vista gera.

\textbf{1)} Seja a seguinte consulta: "Liste todos os cursos de Física oferecidos no 2º semestre do ano de 2017 que estão no edifício Watson).". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT course_id
FROM fisica_1semestre_2017
WHERE building = 'Watson';
\end{lstlisting}

Naturalmente, podemos criar vistas que usem vistas na sua consulta, desde que as vistas usadas na consulta estejam previamente definidas. Ou seja,
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE VIEW fisica_1semestre_2017_watson AS
    SELECT course_id, room_number
    FROM fisica_1semestre_2017
    WHERE building = 'Watson';
\end{lstlisting}

\subsection{Vistas Materializadas}
Certos SGBD permitem relações serem armazenadas, mas para tal, se relações que são usadas em vistas mudarem, a vista é mantida atualizada - tais vistas são chamadas \textbf{vistas materializadas}.

Isto permite que os resultados duma vista sejam armazenados na base de dados, permitindo consultas que usem a vista para potencialmente \textbf{correrem muito mais rapidamente}, pois usa resultados pré-computados, ao invés de recomputá-los.

Assim, se um tuplo \textit{instructor} é adicionada à relação \textit{instructor} e uma vista usa essa mesma relação, é necessário manter a vista atualizada - o processo de manter a \textbf{vista materializada} atualizada é designado \textbf{manutenção da vista}. Este processo pode ocorrer imediatamente quando uma das relações da qual a vista depende é atualizada, ou de um modo preguiçoso, apenas quando a vista é acedida. 

Aplicações que usam uma vista frequentemente ou que necessitam resposta rápida a certas consultas que computam agregações sobre relações grandes beneficiariam de uma \textbf{vista materializada}.

No contexto do PostgreSQL (SGBD da cadeira), eis os comandos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Criar vistas materializadas
CREATE MATERIALIZED VIEW view_exemplo AS SELECT ...

-- Criar tabelas materializadas
CREATE TABLE table_exemplo AS SELECT ...

-- Atualizacao de vista materializada (MANUAL)
REFRESH MATERIALIZED VIEW view_exemplo

-- Atualizacao de vista materializada (AUTOMATICO)
CREATE UNIQUE INDEX idx_view_exemplo
ON view_exemplo(atributo);

REFRESH MATERIALIZED VIEW CONCURRENTLY view_exemplo;
\end{lstlisting}

\subsection{Atualização de Vistas}
Nem todas as vistas são atualizáveis diretamente a partir dos respetivos comandos de atualização, pois a vista pode depender de várias relações simultaneamente.

Em geral, no SQL uma vista diz-se \textbf{atualizável}, i.e., permite o uso dos comandos \textbf{UPDATE}, \textbf{INSERT} e \textbf{DELETE} sse:
\begin{itemize}
    \itemsep0cm
    \item[--] A cláusula \textbf{FROM} só tem 1 relação;
    \item[--] A cláusula \textbf{SELECT} contém apenas nomes de atributos da relação e \textbf{não tem} quaisquer expressões, agregações ou especificações \textbf{DISTINCT};
    \item[--] Qualquer atributo na cláusula \textbf{SELECT} pode ser posto a \textbf{null}; i.e, não tem uma restrição \textbf{not null} e não faz parte da chave primária;
    \item[--] A consulta não tem as cláusulas \textbf{GROUP BY} ou \textbf{HAVING}.
\end{itemize}

Contudo, as vistas podem também ser definidas com a opção \textbf{WITH CHECK} que aquando da tentativa de atualização da vista, se as restrições especificados na opção não forem verificadas, a atualização é descartada.

\section{Restrições de Integridade}
\begin{definition}[Restrição de Integridade]
    Uma restrição de integridade assegura que mudanças feitas à base de dados por utilizadores \textbf{autorizados} não resultam em perca de consistência de dados.
\end{definition}

\subsection{Restrições em 1 Relação}
Como já vimos, a criar tabelas podemos ter instruções de restrições de integridade. Eis algumas delas:
\begin{itemize}
    \itemsep0cm
    \item[--] \textbf{PRIMARY KEY} (já vimos anteriormente)
    \item[--] \textbf{NOT NULL}
    \item[--] \textbf{UNIQUE}
    \item[--] \textbf{CHECK}($<$predicado$>$)
\end{itemize}

\subsection{Restrição NOT NULL}
Para certos atributos, o valor null pode ser desapropriado. Por exemplo, na relação \textit{student} não faz sentido ter o atributo \textit{name} a null, pois representa um estudante desconhecido.
Assim, adicionaríamos ao criar a relação \textit{student}:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE TABLE student 
    (...,
    name VARCHAR(20) NOT NULL,
    ...;
\end{lstlisting}
Esta restrição proíbe a inserção de um valor null para o atributo especificado, e é um exemplo de uma \textbf{restrição de domínio}. 

De notar também que o SQL, por defeito, não permite valores null em atributos que constituam a \textbf{chave primária} de uma relação.

\subsection{Restrição UNIQUE}
A especificação \textbf{UNIQUE} forma uma super-chave - nenhuns 2 tuplos na relação podem ter os atributos especificados no \textbf{UNIQUE} iguais. Um exemplo de uma espeficação \textbf{UNIQUE} é dado por:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
UNIQUE (name, age, gender)
\end{lstlisting}

\subsection{Cláusula CHECK}
Um uso comum da cláusula \textbf{CHECK} é assegurar que valores de atributos satisfazem condições especificadas. Por exemplo, usando valores da vida real, convém que um orçamento para um departamento seja um número real positivo.
Temos então:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Podemos escrever no fim
CREATE TABLE department
    (dept_name VARCHAR(20),
     building VARCHAR(15),
     budget NUMERIC(12, 2),
    PRIMARY KEY (dept_name),
    CHECK (budget > 0));
-- Ou a declarar o atributo
CREATE TABLE department
    (dept_name VARCHAR(20),
     building VARCHAR(15),
     budget NUMERIC(12, 2) CHECK (budget > 0),
    PRIMARY KEY (dept_name));
\end{lstlisting}
A cláusula \textbf{CHECK} permite atribuir restrições ao domínio de um atributo de uma forma potente.

\subsection{Integridade de Referenciamento}
Por vezes, queremos assegurar que um valor que aparece numa relação para um dado conjunto de atributos também aparece num conjunto de atributos duma outra relação. Tais condições dizem-se ser as \textbf{restrições de intregidade de referenciamento}, e as \textbf{FOREIGN KEY} são uma forma dessas restrições onde os atributos referenciados formam uma \textbf{chave primária} na relação referenciada. Eis um exemplo:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Podemos escrever no fim
CREATE TABLE course
    (course_id VARCHAR(8),
     title VARCHAR(50),
     dept_name VARCHAR(20),
     credits NUMERIC(2, 0) CHECK (credits > 0),
    PRIMARY KEY (course_id),
    FOREIGN KEY (dept_name) REFERENCES department);
-- Ou a declarar o atributo
CREATE TABLE course
    (course_id VARCHAR(8),
     title VARCHAR(50),
     dept_name VARCHAR(20) REFERENCES department,
     credits NUMERIC(2, 0) CHECK (credits > 0),
    PRIMARY KEY (course_id));
\end{lstlisting}

Esta declaração \textbf{FOREIGN KEY} exige que para cada tuplo em \textit{course}, o nome do departamento especificado tem de existir na relação \textit{department}.

Quando uma restrição de integridade de referenciamento é violada, o procedimento normal é rejeitar a ação que causou o violamento. Contudo, uma cláusula \textbf{FOREIGN KEY} pode especificar que se uma ação de remoção ou atualização na relação referida for violada, o sistema deve seguir alguns passos para mudar o tuplo na relação em que a restrição é definida para restaurar a mesma. Seja:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE TABLE course
    (...
    FOREIGN KEY (dept_name) REFERENCES department
                    ON DELETE CASCADE
                    ON UPDATE CASCADE,
    ...);
\end{lstlisting}
A cláusula \textbf{ON DELETE CASCADE} fará com que se removermos um tuplo na relação \textit{department} que resulte na violação desta restrição de integridade na relação \textit{course}, o sistema "por cascata" apaga os tuplos em \textit{course} que referenciavam aquele nome de departamento. O comportamento do \textbf{ON UPDATE CASCADE} é análogo.

Se quisermos outro comportamento em vez de ser apagar o tuplo em \textit{course}, podemos definir o valor a null, metendo a cláusula \textbf{SET NULL} no lugar de \textbf{CASCADE}.

\subsection{Restrições Nomeadas}
É possível denominar uma restrição de integridade. Pode ser útil se quisermos remover uma restrição que fora definida previamente.
Para tal, temos o exemplo:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Criar a restricao nomeada
CREATE TABLE instructor
    (...
    salary NUMERIC(8, 2), CONSTRAINT minsalary CHECK (salary > 1000),
    ...);
-- Remover a restricao
ALTER TABLE instructor DROP CONSTRAINT minsalary;
\end{lstlisting}

\section{Autorização}
Podemos atribuir a um utilizador várias formas de autorização em partes da base de dados. 

Para criarmos/removermos um utilizador usamos os seguintes comandos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Criar um utilizador
CREATE USER 'Aragonez' WITH PASSWORD 'Joao';
-- Remover um utilizador
DROP USER [IF EXISTS] 'Aragonez';
\end{lstlisting}

Os vários tipos de autorização chamam-se \textbf{privilégios} e estes são:
\begin{itemize}
    \itemsep0cm
    \item[--] Autorização para ler dados;
    \item[--] Autorização para inserir novos dados;
    \item[--] Autorização para atualizar dados;
    \item[--] Autorização para remover dados.
\end{itemize}
Quando um utilizador submete uma operação de consulta ou atualização, a implementação SQL verifica primeiramente se a operação é autorizada, com base nos privilégios do utilizador - se não for autorizada, é rejeitada.

\subsection{Concessão e Revogação de Privilégios}
O SQL \textit{standard} inclui os \textbf{privilégios} \textbf{SELECT, INSERT, UPDATE} e \textbf{DELETE}. Inclui ainda o privilégio \textbf{ALL} que é um atalho para todos os privilégios anteriores.

A DDL do SQL inclui comandos para conceder e revogar privilégios. A instrução \textbf{GRANT} é usada para conferir autorização e tem a seguinte forma geral:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
GRANT <lista de privilegios>
ON <nome da relacao ou vista>
TO <lista de utilizadores/papeis>
\end{lstlisting}

A autorização \textbf{SELECT} numa relação é necessária para ler tuplos na relação. Um exemplo de querermos dar ao utilizador "Aragonez" (utilizador de escolha daqui em diante) autorização para fazer consultas \textbf{SELECT} na relação \textit{department} é dado por:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, TO}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
GRANT SELECT
ON department
TO Aragonez
\end{lstlisting}

A autorização \textbf{UPDATE} numa relação permite o utilizador atualizar qualquer tuplo na relação - podem ser dado todos os atributos da relação ou apenas alguns. No caso de selecionarmos apenas alguns atributos, devem ser seguidos da cláusula \textbf{UPDATE} um conjunto de parêntes ( ) com os atributos lá dentro especificados. Por exemplo:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, TO}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
GRANT UPDATE (budget)
ON department
TO Aragonez
\end{lstlisting}

A autorização \textbf{INSERT} numa relação permite o utilizador inserir tuplos na relação - podem ser dado todos os atributos da relação ou apenas alguns. No caso de selecionarmos apenas alguns atributos, devem ser seguidos da cláusula \textbf{INSERT} um conjunto de parêntes ( ) com os atributos lá dentro especificados. Para os valores que não pertençam a este conjunto, o sistema ou lhes atribui um valor \textbf{DEFAULT} se assim o for especificado, ou mete-os a \textbf{NULL}.
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, TO}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
GRANT INSERT (budget)
ON department
TO Aragonez
\end{lstlisting}

A autorização \textbf{DELETE} numa relação permite o utilizador remover tuplos duma relação.
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, TO}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
GRANT DELETE
ON department
TO Aragonez
\end{lstlisting}

O utilizador \textit{public} refere-se ao utilizador atual e todos os futuros utilizadores do sistema - os seus privilégios são-lhes concecidos implicitamente.

O mecanismo de autorização do SQL concede privilégios numa relação inteira, ou em atributos específicos de uma relação. Contudo, não permite autorizações em tuplos específicos de uma relação.

Para revogar uma autorização, usamos a instrução \textit{REVOKE}, que tem uma forma geral análoga à \textbf{GRANT}:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
REVOKE <lista de privilegios>
ON <nome da relacao ou vista>
TO <lista de utilizadores/papeis>
\end{lstlisting}

Para revogarmos os privilégios concedidos previamente escrevemos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
REVOKE SELECT ON department FROM Aragonez;
REVOKE UPDATE (budget) ON department FROM Aragonez;
REVOKE INSERT (budget) ON department FROM Aragonez;
REVOKE DELETE ON department FROM Aragonez;
\end{lstlisting}

\subsection{Papéis}
Consideremos os papéis das várias pessoas no mundo real. Seja um papel por exemplo um instrutor, professor-assistente e estudante exemplos de papéis num contexto universitário. 

Quando um novo instrutor for contratado, um identificador de utilizador terá de ser alocado a ele, e este deve ser identificado com o papel de instrutor, que engloba em si um conjunto de permissões no sistema.

A noção de \textbf{papéis} em SQL captura este conceito - um conjunto de papéis é criado na base de dados, e autorização são concedidas a papéis da mesma forma que são concedidas a utilizadores.

É verdade que poderíamos criar um único utilizador \textit{instrutor} e todos acederem a partir desse mesmo, mas por questões de segurança, é preferível identificar exatamente que instrutor executou uma certa operação sobre a base de dados.

Os \textbf{papéis} em SQL são criados da seguinte maneira:
\begin{lstlisting}[language=SQL, morekeywords={TO}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Criar o papel
CREATE ROLE instructor;

-- Conceder permissoes
GRANT SELECT
ON takes
TO instructor;

-- Papeis podem ser concedidos a utilizadores bem como a outros papeis
CREATE ROLE dean;
GRANT 
instructor 
TO dean;

GRANT UPDATE
ON takes 
TO dean;

GRANT dean TO Aragonez;
\end{lstlisting}

Os privilégios de um utilizador/papel consistem em:
\begin{itemize}
    \itemsep0cm
    \item[--] Todos os privilégios concedidos diretamente ao utilizador/papel;
    \item[--] Todos os privilégios concedidos aos papéis que foram concedidos ao utilizador/papel.
\end{itemize}
Isto pode criar correntes de papéis, o que deve ser gerido cuidadosamente.

\subsection{Autorização em Vistas}
Como vimos, as vistas também podem ser alvo de autorização.

Porém, é importante notar que um utilizador que cria uma vista não recebe necessariamente todos os privilégios da vista - só recebe os privilégios que não requiram autorização adicional para além do que o que já possui. Por exemplo, um utilizador que cria uma vista não pode ter a autorização \textbf{UPDATE} numa vista sem tem autorização \textbf{UPDATE} em todas as relações que a vista refere - se o utilizador criar uma vista sem permissões suficientes para tal, o sistema nega-lhe o pedido de criação de vista.

\subsection{Autorização em Esquemas}
O SQL \textit{standard} especifica um mecanismo de autorização primitivo para o esquema de base de dados: apenas o \textbf{dono do esquema} pode modificá-lo, como criar e remover \textbf{relações}, adicionar ou tirar \textbf{atributos de relações}, bem como adicionar ou tirar \textbf{índices}.

Contudo, o SQL fornece um privilégio \textbf{REFERENCES} que permite a um utilizar declarar chaves secundárias ao criar relações. O privilégio é concedido a atributos específicos como o privilégio \textbf{UPDATE}. Passo a exemplificar:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, TO}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
GRANT REFERENCES (dept_name) ON department TO Aragonez;
\end{lstlisting}

\section{Funções e Procedimentos}
\subsection{Introdução}
\begin{definition}[Base de Dados Centrada Em Dados]
    O desenvolvimento de uma base de dados centrada em dados é uma abordagem de desenvolvimento onde instruções procedimentais (como um sub-programa em qualquer linguagem de programação) pode ser armazenado dentro de uma base de dados também conhecidas como \textbf{stored program} / \textbf{stored routine}.
\end{definition}

Um \textbf{Persistent Stored Module} (\textbf{PSM}) pode ser de 2 tipos:
\begin{itemize}
    \itemsep0cm
    \item[--] Uma \textbf{stored function} que \textbf{retorna um valor} mas \textbf{não altera} o estado da base de dados - combina \textit{inputs} e resultados das consultas da base de dados para produzir o \textit{output}.
    \item[--] Um \textbf{stored procedure} que \textbf{pode mudar} o estado da base de dados e \textbf{não retorna nenhum valor} - consulta e atualiza a base de dados.
\end{itemize}

As vantagens de usarmos \textbf{PSM}:
\begin{itemize}
    \itemsep0cm
    \item[--] Torna as aplicações \textbf{mais rápidas}: os PSM são compilados e mantidos dentro da base de dados.
    \item[--] \textbf{Reduz a troca de dados}: especialmente entre a aplicação e o servidor da base de dados.
    \item[--] Introduz \textbf{1 nível de indireção}: pode ser chamado por aplicações escritas em linguagens distintas.
\end{itemize}

As desvantagens de usarmos \textbf{PSM}:
\begin{itemize}
    \itemsep0cm
    \item[--] \textbf{Debugging} e \textbf{profiling} pode ser extremamente difícil;
    \item[--] O ambiente de desenvolvimento depende altamente do SGBD usado.
\end{itemize}

Funções e procedimentos permitem que a "lógica de negócio" seja guardada na base de dados e executada a partir de instruções de SQL. Por exemplo, universidades têm várias regras sobre quantas cadeiras um estudante por detirar ao mesmo tempo num dado semestre. 

\subsection{Declaração e Invocação de Funções e Procedimentos SQL}
Para definirmos/removermos um procedimento ou uma função:
\begin{lstlisting}[language=SQL, morekeywords={PROCEDURE, FUNCTION, REPLACE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Criar
CREATE [OR REPLACE] PROCEDURE/FUNCTION ...
-- Remover
DROP PROCEDURE/FUNCTION ...
\end{lstlisting}

Para invocarmos um procedimento ou uma função (podem ser chamados a partir de outros procedimentos ou de aplicações a nível do cliente):
\begin{lstlisting}[language=SQL, morekeywords={CALL}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Chamar procedimento
CALL procedure_name [(param1, param2, ...)]
-- Chamar funcao
my_function_name([param1, param2, ...])
\end{lstlisting}

\textbf{1)} Seja a seguinte operação: "Cria um procedimento que insere o tipo de gomas preferidas do João Aragonez na relação \textit{aragonez\_senior\_shopping\_list} mediante o seu grau de fome ($<50\%$ são as gomas ácidas, caso contrário são as doces)". Temos:
\begin{lstlisting}[language=SQL, morekeywords={CALL, DECLARE, PROCEDURE, IF}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE PROCEDURE fome_aragonez(IN grau_fome INTEGER) AS

DECLARE gomas VARCHAR(6);
BEGIN
    IF grau_fome < 50
    THEN
        SET gomas := 'acidas';
    ELSE
        SET gomas := 'doces';
    END IF;
    INSERT INTO aragonez_senior_shopping_list
        VALUES (gomas);
END
\end{lstlisting}

É de notar que o PostgreSQL não suporta \textbf{stored procedures} verdadeiros (um \textbf{PROCEDURE} em PostgreSQL é uma \textbf{FUNCTION} que retorna o \textit{type} \textbf{VOID}); apenas \textbf{stored functions} são suportadas.

As \textbf{stored functions} na sua forma geral são:
\begin{lstlisting}[language=SQL, morekeywords={FUNCTION, RETURNS, $$, LANGUAGE, DECLARE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE FUNCTION my_func([parametros]) 
RETURNS type AS
$$
DECLARE [declaracoes]
BEGIN
    [instrucoes]
END
$$ LANGUAGE plpgsql;
\end{lstlisting}
De notar que o \textbf{PSM} no Postgres permite o \textit{type} ser \textbf{VOID}.

\textbf{2)} Seja a seguinte operação: "Cria uma função que recebe 2 \textit{numeric}'s como \textit{input} e que retorna outro \textit{numeric} correspondente à soma dos dois.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={FUNCTION, RETURNS, $$, LANGUAGE, DECLARE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE FUNCTION add_nums(
    x NUMERIC,
    y NUMERIC) 
    RETURNS NUMERIC AS
$$
BEGIN
    RETURN x + y;
END
$$ LANGUAGE plpgsql;
\end{lstlisting}

Podemos usar as \textbf{stored functions} nas cláusulas \textbf{SELECT} e \textbf{WHERE}. Exemplificando:
\begin{lstlisting}[language=SQL, morekeywords={FUNCTION, RETURNS, $$, LANGUAGE, DECLARE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Sem clausula FROM
SELECT add_me(2, 3);

-- Como uma expressao no SELECT (aplicado a cada tuplo de instructor)
SELECT name, add_me(salary, 100)
FROM instructor

-- Como uma expressao no WHERE (aplicado a cada tuplo de instructor)
SELECT *
FROM instructor
WHERE add_me(salary, -1000) < 1000
\end{lstlisting}

\begin{definition}[Função Determinística]
Uma função é determinística se produz sempre o mesmo resultado para os mesmos valores de \textit{input}.
\end{definition}
Em PostgreSQL, as função são \textbf{não-determinísticas} por defeito, pelo que se quisermos especificar que a função é determinística devemos usar o seguinte comando:
\begin{lstlisting}[language=SQL, morekeywords={FUNCTION, RETURNS, $$, LANGUAGE, DECLARE, IMMUTABLE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE FUNCTION myfunc([params]) 
RETURNS type IMMUTABLE
\end{lstlisting}

As funções e procedimentos permitem a \textbf{declaração de variáveis}, como já vimos, sem complexidade alguma. A sua forma geral é dada por:
\begin{lstlisting}[language=SQL, deletekeywords={VALUE}, morekeywords={FUNCTION, RETURNS, $$, LANGUAGE, DECLARE, IMMUTABLE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
DECLARE var_name [, var_name2 ...] type [DEFAULT value]
\end{lstlisting}
Estas são apenas visíveis dentro do scope \textbf{BEGIN} \dots \textbf{END}.

Um pequeno exemplo é dado por:
\begin{lstlisting}[language=SQL, deletekeywords={VALUE}, morekeywords={FUNCTION, RETURNS, $$, LANGUAGE, DECLARE, IMMUTABLE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
DECLARE 
    first_name VARCHAR(50) DEFAULT 'Joao';
    last_name VARCHAR(50) DEFAULT 'Aragonez';
    contador INTEGER := 1; -- eh assim que se fazem atribuicoes em PostgreSQL
    pagamento NUMERIC(11, 2) := 20.5;
\end{lstlisting}
As variáveis podem também ser declaradas para captarem o resultado de uma consulta usando a cláusula \textbf{INTO}. Exemplificando a forma geral:
\begin{lstlisting}[language=SQL, deletekeywords={VALUE}, morekeywords={INTO}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
BEGIN
    ...
    SELECT col_name, ...
    INTO var_name
    FROM ...
    ...
END

\end{lstlisting}
É rápido para perceber que se quisermos vários atributos de uma relação guardados numa variável declarada, não existe nenhum \textit{type} pré-definido que as albergue sem problemas. Para isso, podemos criar o nosso próprio tipo, representado em baixo um exemplo de um tipo relevante:
\begin{lstlisting}[language=SQL, morekeywords={CREATE, TYPE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE TYPE gomas_aragonez AS (
    tipo VARCHAR(6),
    preco_max NUMERIC(1, 2),
    perc_acucar NUMERIC(3, 2)
);
\end{lstlisting}
De notar que esta criação de tipos permite também ser fornecido como \textit{type} de retorno de uma \textbf{stored function}.

\subsection{Construtores de Linguagem para Funções e Procedimentos}
Existem várias instruções dentro do scope \textbf{BEGIN} \dots \textbf{END} da função/do procedimento.

A sintaxe para instruções \textbf{WHILE} e \textbf{REPEAT} é dada por:
\begin{lstlisting}[language=SQL, morekeywords={CREATE, TYPE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Ciclo WHILE
WHILE expressao booleana DO
    sequencia de instrucoes;
END WHILE

-- Ciclo REPEAT
REPEAT
    sequencia de instrucoes;
UNTIL expressao boleana
END REPEAT

-- As palavras-chave break, continue e return nos ciclos em PostgreSQL sao dados por
EXIT -- sai do loop
CONTINUE -- continua o loop
RETURN -- sai da funcao (e do loop)
\end{lstlisting}

Existe ainda um ciclo \textbf{FOR} que permite iterar sobre os resultados de uma consulta:
\begin{lstlisting}[language=SQL, morekeywords={DECLARE, FOR, DO}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
DECLARE n INTEGER DEFAULT 0;
FOR r AS
    SELECT budget FROM department
    WHERE dept_name = 'Musica'
DO
    SET n = n - r.budget
END FOR
\end{lstlisting}

A sintaxe para instruções \textbf{IF-THEN-ELSE} é dada por:
\begin{lstlisting}[language=SQL, morekeywords={IF, DECLARE, FOR, DO}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
IF expressao booleana
    THEN instrucao ou instrucao composta
ELSE IF expressao booleana
    THEN instrucao ou instrucao composta
ELSE instrucao ou instrucao composta
END IF
\end{lstlisting}

Se quiser ter o \textbf{PSM} a retornar \textbf{relações inteiras ou parciais} basta usar na cláusula \textbf{RETURNS} a palavra-chave \textbf{SETOF $<$relação$>$} se a quisermos na íntegra ou \textbf{TABLE(atr\_1 type(atr\_1), ..., atr\_m type(atr\_m))} se quisermos uma tabela parcialmente, assumindo que $m < n$, onde $n$ é o número de nomes de atributos diferentes na relação.

Para ter o \textbf{PSM} a retornar \textbf{apenas um tuplo da relação} basta declarar uma variável do seguinte modo:
\begin{lstlisting}[language=SQL, morekeywords={$$, RETURNS, DECLARE, ROWTYPE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
...
RETURNS table_name AS
$$
DECLARE
    var_name table_name%ROWTYPE
\end{lstlisting}

\subsection{Blocos DO}
Os blocos \textbf{DO} executam uma função anónima (sem qualquer nome atribuído). Eis um exemplo:
\begin{lstlisting}[language=SQL, morekeywords={DECLARE, FOR, DO, $$, RAISE, INFO}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
DO $$
DECLARE total NUMERIC DEFAULT 0;
BEGIN
    SELECT sum(salary)
    INTO total
    FROM instructor;
    RAISE INFO 'Total salarios pagos a instrutores --> %', total;
END
$$;
\end{lstlisting}



\section{Triggers}
\begin{definition}
    Um trigger é uma instrução que o sistema executa automaticamente aquando de uma modificação na base de dados (operações como \textbf{INSERT, UPDATE} ou \textbf{DELETE}).
\end{definition}

Para definirmos um trigger devemos:
\begin{itemize}
    \itemsep0cm
    \item[--] Especificar quando é que o trigger é suposto ser executado. Isto decompõe-se num \textit{evento} que causa o trigger a ser verificado e uma \textit{condição} deve ser satisfeita para a execução do trigger proceder.
    \item[--] Especificar as \textit{ações} a tomar quando o trigger executar.
\end{itemize}
Diz-se então que os triggers são especificados usando as regras \textbf{\textit{event-condition-action}}.

\subsection{Necessidade de Triggers}
Os triggers podem ser usados para:
\begin{itemize}
    \itemsep0cm
    \item[--] Implementar certas \textbf{restrições de integridade};
    \item[--] \textbf{Agir automaticamente} mediante a junção de certas condições bem definidas - estas ações podem ser atualizar/mudar/replicar relações, tirar medidas de estatística, etc.
\end{itemize}

\subsection{Triggers em SQL}
Como sabemos, um trigger é um procedimento que é automaticamente invocado em resposta a certas atualizações da base de dados.

A sua sintaxe em SQL é dada por:

\begin{lstlisting}[language=SQL, morekeywords={TRIGGER, BEFORE, AFTER, FOR, EACH, ROW, STATEMENT, PROCEDURE, IF}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Criar um trigger
CREATE TRIGGER <nome_trigger>
    { BEFORE | AFTER } { INSERT | UPDATE | DELETE }
ON <nome_relacao ou nome_vista>
WHEN <condicao>
FOR EACH { ROW | STATEMENT } EXECUTE PROCEDURE <nome_proc>

-- Remover um trigger
DROP TRIGGER <nome_trigger> ON <nome_relacao ou nome_vista> [IF EXISTS]
\end{lstlisting}

\textbf{1)} Seja a seguinte operação: "Cria um trigger que não permite que o salário de um instrutor seja abaixo de 800 nem acima de 3000.". Temos:

\begin{lstlisting}[language=SQL, morekeywords={TRIGGER, REPLACE, FUNCTION, RETURNS, $$, IF, NEW, ELSEIF, ENDIF, RETURN, NEW, LANGUAGE, AFTER, FOR, EACH, ROW, PROCEDURE, BEFORE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Criar o procedimento a executar aquando de um trigger
CREATE OR REPLACE FUNCTION verf_salario_proc()
RETURNS TRIGGER AS
$$
BEGIN
    IF NEW.balance < 800 THEN
        NEW.balance := 800;
    ELSEIF NEW.balance > 3000 THEN 
        NEW.balance := 3000;
    ENDIF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Definir o trigger
CREATE TRIGGER verf_salario_trigger
    BEFORE INSERT
    ON instructor
    FOR EACH ROW
    EXECUTE PROCEDURE verf_salario_proc();
\end{lstlisting}

O comportamento dos triggers mediante serem \textbf{BEFORE} ou \textbf{AFTER} da operação que modifica a base de dados é resumido em:

\begin{table}[H]
\begin{tabular}{l|c|c|}
\cline{2-3}
& BEFORE & AFTER \\ \hline
\multicolumn{1}{|l|}{\cellcolor[HTML]{C1FFC1}ACTIVATION} & \begin{tabular}[c]{@{}c@{}}O trigger é ativado 1 vez\\ para cada tuplo ou instrução.\end{tabular}                         & \begin{tabular}[c]{@{}c@{}}O trigger é ativado 1 vez para\\ cada tuplo ou instrução sse:\\ - Todos os triggers BEFORE na\\ mesma relação e os relativos à\\ mesma operação são executados\\ com sucesso;\\ - A operação foi executada com \\ sucesso.\end{tabular} \\ \hline
\multicolumn{1}{|l|}{\cellcolor[HTML]{FFCCC9}FAILURE}    & \begin{tabular}[c]{@{}c@{}}A operação na fila/relação\\ não é executada.\\ Nenhum trigger AFTER é\\ ativado.\end{tabular} & \begin{tabular}[c]{@{}c@{}}A operação na fila/relação\\ não é executada.\end{tabular} \\ \hline
\end{tabular}
\end{table}

\subsection{Problemas dos Triggers}
Os triggers têm \textit{um efeito complexo}, por vezes imprevisível, pois vários triggers podem serem ativados numa única operação e a ação de um trigger pode ativar outro (\textbf{triggers recursivos}).

Podem, como tal, gerar \textit{ciclos de eventos}, com muita dificuldade em depurar e corrigir, bem como instanciar \textit{execuções indesejadas} pois mudanças a uma tabela podem gerar triggers por cadeia que não eram intencionados serem executados.

Se \textit{ocorrerem erros} e o trigger falhar, a operação inteira falha, e é complexa a sua recuperação de falta.

\subsection{Quando Não Usar Triggers}
\begin{itemize}
    \itemsep0cm
    \item[--] \textit{Tabelas de Resumo}: usar \textbf{VIEW}s em vez de \textbf{TRIGGER}s, se possível;
    \item[--] \textit{Restrições de Integridade Complexas}: usar \textbf{CHECK}s sempre que possível;
    \item[--] \textit{Replicação de Relações}: usar os mecanismos embutidos do SGBD.
\end{itemize}

\chapter{Desenvolvimento de Aplicações com Bases de Dados}
A maneira mais comum dos utilizadores interagirem com bases de dados é através de \textit{programas aplicacionais} que fornecem uma interface ao utilizador no \textit{frontend} e interfaces com a base de dados no \textit{backend}.

\section{Programas Aplicacionais e Interfaces de Utilizador}
Um \textit{programa aplicacional} típico contém uma componente \textit{frontend}, que lida com a interface do utilizador, uma componente \textit{backend}, que comunica com a base de dados, e uma \textit{middle layer}, que contém lógica de negócio, i.e., código que executa pedidos específicos para informação ou atualizações - os comandos SQL podem ser invocados através de qualquer aplicação informática, escrita em qualquer linguagem (\textit{Java, C, PHP, Python, ...}).

Para evitar acesso direto do utilizador à base de dados, que compromete a segurança da mesma, e para haver um único ponto de mudança, i.e., se um utilizador fizer uma mudança local, esta está automaticamente disponível aos demais utilizadores da aplicação e estes não precisarem de descarregar/atualizar a aplicação localmente, usam-se 2 abordagens:

\begin{itemize}
    \itemsep0cm
    \item[--] \textit{Web browsers} oferecem uma \textbf{\textit{frontend} universal} - usam HTML (\textbf{linguagem \textit{markup}}) como sintaxe e apresentam o conteúdo das páginas de forma "gráfica" ao utilizador.
    \item[--] Os programas são instalados localmente, mas comunicam com as aplicações \textit{backend} através de uma \textbf{API} e não têm acesso direto à aplicação - é mais usada em aplicações móveis e o seu resultado é normalmente \textbf{XML}.
\end{itemize}

O modelo de arquitetura de aplicações \textit{web} lecionado na cadeira é o seguinte:
\begin{figure}[H]%
    \centering
    \subfloat[\centering Arquitetura Aplicação Web]{{\includegraphics[width=8.1cm]{cap_web/arquitetura_web.png} }}%
    \qquad
    \subfloat[\centering Distribuição Física]{{\includegraphics[width=8.1cm]{cap_web/dist_fisica.png} }}%
    \caption{Aplicações Web em BD}%
    \label{fig:example}%
\end{figure}

\section{Acesso a SQL numa Linguagem de Programação}
Existem 2 abordagens para aceder a SQL numa linguagem de programação:
\begin{itemize}
    \itemsep0cm
    \item[--] \textbf{SQL dinâmico}: permite o programa construir consultas SQL como uma cadeia de caracteres em \textit{runtime}, submeter a consulta e colocar o resultado em variáveis do programa, um tuplo de cada vez.
    \item[--] \textbf{SQL embutido}: as instruções SQL são identificadas em tempo de compilação usando um pré-processamento que traduz os pedidos feito em SQL embutido em chamadas de funções.
\end{itemize}

\subsection{SQL Embutido}
Uma linguagem na qual consultas SQL são embutidas é referida como a \textit{linguagem host}, e as estruturas SQL permitidas na \textit{linguagem host} constituem o \textbf{SQL embutido}.

Programas escritos na \textit{linguagem host} podem usar SQL embutido para aceder e atualizar dados guardados na base de dados - existe um pré-processamento feito antes da compilação que transforma pedidos SQL embutidos com declarações na \textit{linguagem host} e chamadas a procedimentos que permitem o acesso à base de dados durante o \textit{runtime}.

Para identificar pedidos SQL embutidos ao pré-processador, usamos a instrução \textbf{EXEC SQL}, com a forma geral:

\begin{lstlisting}[language=SQL, morekeywords={TRIGGER, REPLACE, FUNCTION, RETURNS, $$, IF, NEW, ELSEIF, ENDIF, RETURN, NEW, LANGUAGE, AFTER, FOR, EACH, ROW, PROCEDURE, BEFORE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
EXEC SQL <instrucao SQL embutida>;
\end{lstlisting}

Inicialmente, o programa deve-se conectar à base de dados:
\begin{lstlisting}[language=SQL, morekeywords={char*, EXEC, SQL, CONNECT, IDENTIFIED, DECLARE, SECTION}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Para o exemplo iremos usar C como linguagem host
-- Declaracao de variabeis
char* gomas = "Gomas! Yummy!";
EXEC SQL BEGIN DECLARE SECTION
char* username = "Aragonez";
char* password = "Joao";
EXEC SQL END DECLARE SECTION
-- Conexao ah base de dados
EXEC SQL CONNECT :username IDENTIFIED BY :password
-- Codigo C
printf("%s\n", gomas);
\end{lstlisting}

Como vimos, as variáveis da \textit{linguagem host} podem ser usadas em instruções de SQL embutido, mas têm de ser precedidos por dois pontos (:), para as distinguir das variáveis do SQL embutido (\textbf{SQLCODE} que é um \textit{long} que retorna negativo se existir um erro e \textbf{SQLSTATE} que é uma cadeia de caracteres que indica o tipo de erro).

Para iterar sobre os resultados de uma consulta SQL embutido, devemos declarar uma variável \textbf{CURSOR}, que pode ser aberto, e buscar comandos emitidos num loop da \textit{linguagem host} para buscar linhas consecutivas do resultado da consulta - atributos da linha podem ser metidas em variáveis da \textit{linguagem host}.

Exemplificamos agora com um programa em C que usa SQL embutido:
\begin{lstlisting}[language=SQL, morekeywords={char*, EXEC, SQL, CONNECT, IDENTIFIED, DECLARE, SECTION, CURSOR, FOR, short, FETCH, CLOSE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Declaracao de variabeis
char SQLSTATE[6]; -- variavel do SQL embutido
EXEC SQL BEGIN DECLARE SECTION
char c_iname[30];
short c_minsalary;
float c_iage;
EXEC SQL END DECLARE SECTION
c_minsalary = random();
-- Declarar o cursor para a consulta SQL embutida
EXEC SQL DECLARE iinfo CURSOR FOR
    SELECT name, age
    FROM instructor
    WHERE salary > :c_minsalary
    ORDER BY name;
-- Ciclo na linguagem host para dar fetch
do {
    EXEC SQL FETCH iinfo INTO :c_iname, :c_age; -- dar fetch p variaveis locais
    printf("%s is %d years old!\n", c_iname, c_age); -- codigo C puro
} while (SQLSTATE != '02000');
EXEC SQL CLOSE iinfo; -- fechar o cursor
\end{lstlisting}

Podemos ainda usar a instrução SQL \textbf{PREPARE} para executar instruções de SQL embutido pré-definidas, como por exemplo:
\begin{lstlisting}[language=SQL, morekeywords={char*, EXEC, SQL, CONNECT, IDENTIFIED, DECLARE, SECTION, CURSOR, FOR, short, FETCH, CLOSE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Variavel da linguagem host com instrucao SQL embutida definida
char c_sqlstring[] = {"DELETE FROM instructor WHERE age > 65"};
-- Correr a instrucao da variavel
EXEC SQL PREPARE foobar FROM :c_sqlstring
EXEC SQL EXECUTE foobar
\end{lstlisting}

\section{Programação de Aplicação Web}
A \textbf{Common Gateway Interface (CGI)} define como é que um servidor web comunica com programas aplicacionais. Por sua vez, os programas aplicacionais comunicam com um servidor de base de dados atráveis de \textbf{ODBC/JDBC}.

Como o protocolo \textbf{HTTP} é \textit{connectionless} não existe ligação contínua entre o cliente e o servidor web - quando o servidor recebe um pedido, uma conexão é temporariamente criada que permite a troca de mensagens entre o cliente e o servidor.

Em contraste, quando um utilizador se liga a uma base de dados usando textbf{ODBC/JDBC}, uma sessão é criada e até esta ser terminada toda a informação de sessão é mantida no servidor.

Como as aplicações web (na sua maioria) necessitam de informação de sessão para permitir interagir eficientemente com o utilizador, utilizam-se \textbf{cookies} (já se viu isto em RC, não é relevante explicar como funcionam).

\subsection{Introdução a Scripting, Framework e Driver}
Usamos \textbf{\textit{scripting languages}} e \textbf{\textit{application frameworks}} para processar pedidos no servidor aplicacional.

Em \textbf{server-side scripting}, antes de entregar uma página \textit{Web} ao cliente, o servidor executa os \textit{scripts} embutidos nos conteúdos HTML da página. Cada pedaço do \textit{script}, quando executado, pode gerar texto que é adicionado à página (ou até mesmo apagar). O código-fonte é apagado da página, pelo que o cliente poderá nem saber que havia código nele antes. O \textit{script} executado pode conter código SQL que é executado sobre uma base de dados, bem como usar diretamente valores de input de formulários HTML preenchidos pelo cliente nas consultas SQL.

Em \textbf{client-side scripting}, os browsers conseguem buscar certos scripts do lado do cliente, ou até mesmo programas ou documentos, e executá-los de um "modo seguro" no lado do cliente, como é exemplo de certos scripts \textit{Javascript}, \textit{Adobe Flash} usado para animações/jogos, etc.

O Python oferece 2 frameworks para \textit{server-side scripting}: \textbf{Flask} e \textit{Django}. Oferece ainda um \textit{driver} como modelo de acesso a SGBD: \textbf{Psycopg}.

\subsection{Flask \& Psycopg}
Deixo aqui um fluxo da execução de um servidor Web que opera em conjunto com uma SGBD:
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.5]{cap_web/server_web_sgbd.png}
\end{figure}
A figura acima pode ser legendada da seguinte forma:
\begin{enumerate}
    \itemsep0cm
    \item O cliente realiza um pedido através do protocolo HTTP ao servidor Web;
    \item O servidor Web tenciona executar um programa externo (\textit{script CGI}) escrito numa \textit{scripting language} (Python neste caso);
    \item O servidor Web acede ao sistema de ficheiro local para encontrar o \textit{script} localmente;
    \item O sistema de ficheiros fornece o código Python para ser executado.
    \item Quaisquer consultas SQL que estejam no código são agora realizadas, havendo comunicação com o SGBD;
    \item O SGBD retorna os resultados das consultas;
    \item Os resultados são transformados em HTML e o \textit{server-side script} é apagado da página fonte;
    \item A página é devolvida ao cliente.
\end{enumerate}

Escrevamos agora o nosso \textit{script} usando o framework \textbf{Flask} e o driver \textbf{Psycopg}:

\begin{lstlisting}[language=python, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
#!/user/bin/python3 ## IMPRESCINDIVEL
from wsgiref.handlers import CGIHandler
from flask import Flask
import psycopg2
import psycopg2.extras

## Configuracao do SGBD (Psycopg)
DB_HOST = "db.tecnico.ulisboa.pt"
DB_USER = "aragonez"
DB_DATABASE = "aragonez_db"
DB_PASSWORD = "joao"
DB_CONNECTION_STRING = "host=%s dbname=%s user=%s password=%s" % (
    DB_HOST,
    DB_DATABASE,
    DB_USER,
    DB_PASSWORD,
)

## Configuracao do Framework (Flask)
app = Flask(__name__)
## Pagina principal mostra o index
@app.route("/") ## Decorator - adiciona funcionalidade ao codigo existente
def index():
    try:
        return render_template("index.html") ## render_template built-in do Flask
    except Exception as e:
        return str(e)

## Criar uma categoria
@app.route("/criar_categoria", methods=["POST"]) ## POST pq o cliente enviou dados ao servidor atraves do form
def executar_criar_categoria():
    dbConn = None
    cursor = None
    try:
        ## ligar ah bd
        dbConn = psycopg2.connect(DB_CONNECTION_STRING)
        cursor = dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor)
        ## processamento do input do cliente
        name = request.form['category_to_add']
        if (request.form['category_type'] == 'Simple Category'):
            query = "INSERT INTO categoria_simples VALUES (%s);"
        else:
            query = "INSERT INTO super_categoria VALUES (%s);"
        cursor.execute(query, (name, ))
        query = "INSERT INTO categoria VALUES (%s);"
        cursor.execute(query, (name, ))
        return query ## Retorna o resultado da query como string para o HTML
    except Exception as e:
        return str(e)
    finally:
        dbConn.commit()
        cursor.close()
        dbConn.close()

## Listar os produtos
@app.route('/listar_produtos')
def listar_produtos():
    dbConn = None
    cursor = None
    try:
        dbConn = psycopg2.connect(DB_CONNECTION_STRING)
        cursor = dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor)
        query = "SELECT * FROM product;"
        cursor.execute(query)
        return render_template("listar_produtos.html", cursor=cursor)
    except Exception as e:
        return str(e)
    finally:
        dbConn.commit()
        cursor.close()
        dbConn.close()

## IMPERATIVO ESTAR PRESENTE
CGIHandler().run(app)
\end{lstlisting}

Na função em que listamos os produtos, o código chama a função \textit{render\_template} embutida no próprio \textbf{Flask}. Este procura os \textit{templates} pelo nome do ficheiro dado na pasta \textit{templates}.

O \textbf{Flask} por sua vez usa o \textbf{Jinja2} como seu motor de \textit{templates}. Eis alguns dos \textbf{delimitadores} importantes do mesmo:
\begin{itemize}
    \itemsep 0cm
    \item[--] $\{\% ... \%\}$ declarações, ex.: if, for, while;
    \item[--] $\{\{ ... \}\}$ para expressões a serem substituídas na página gerada;
    \item[--] $\{\# ... \#\}$ para comentários que não devem ser incluídos na página gerada;
    \item[--] $\#$ para uma linha que contém uma instrução
\end{itemize}

Exemplo simples da utilização destes delimitadores (\textit{listar\_produtos.html}):
\begin{lstlisting}[language=html, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
<!doctype html>
<title> Listar Produtos - Flask</title> <body style="padding:20px">
{% if cursor %}
    <table border="2px">
    <thead> <tr>  <th>EAN</th> <th>Descricao</th> <th>Alterar</th> </thead>
    <tbody>
        {% for record in cursor %}
            <tr> <td>{{record[0]}}</td> <td>{{record[1]}}</td> <td><a href="description?product_ean={{record[0]}}">Alterar Descricao</a> </td> </tr>
        {% endfor %}
    </tbody> </table>
{% else %}
    <p> Erro: Falha a obter dados da base de dados! </p>
{% endif %}
\end{lstlisting}

Se notarmos, a terceira entrada da tabela a partir da esquerda (começando em 1) permite alterar a descrição de um produto. Para isso usa um \textbf{href} que leva para uma nova página \textit{description} e leva como argumento o EAN do produto em questão. Agora basta extender o script \textit{CGI} em \textbf{Flask} para permitir realmente mudar a descrição:

\begin{lstlisting}[language=python, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
...

## Configurar o routing para /description
@app.route("/description")
def change_description():
    try:
        ## params = request.args = records[0] passado no listar_produtos.html
        return render_template("description.html", params=request.args)
    except Exception as e:
        return str(e)
\end{lstlisting}

Definimos agora o \textit{template} \textit{description.html}:
\begin{lstlisting}[language=html, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
<html>
    <body>
        <h3>Alterar descricao do produto "{{ params.get("product_ean") }}"</h3>
        <!-- Falta-nos agora usar isto no Flask-->
        <form action="update_desc" method="post">
            <p><input type="hidden" name="ean" value="{{ params.get("product_ean")}}"/></p>
            <p>Nova descricao: <input type="text" name="description"/></p>
            <p><input type="submit" value="Submeter"/></p>
        </form>
    </body>
</html>
\end{lstlisting}

E completamos por fim o \textit{CGI}:
\begin{lstlisting}[language=python, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
...

## Configurar o routing para /description
@app.route("/update_desc", methods=["POST"])
def update_description():
    dbConn = None
    cursor = None
    try:
        dbConn = psycopg2.connect(DB_CONNECTION_STRING)
        cursor = dbConn.cursor(cursor_factory=psycopg2.extras.DictCursor)
        query = f"UPDATE product SET description={request.form["description"]} WHERE ean='{request.form["ean"]}';" ## SUJEITO A INJECAO SQL
        cursor.execute(query)
        return query
    except Exception as e:
        return str(e)
    finally:
        dbConn.commit()
        cursor.close()
        dbConn.close()
\end{lstlisting}

\subsection{Injeção SQL}
O problema com o código acima é que imaginando que no \textit{input} do cliente na \textit{description} do formulário HTML, este mesmo escreve:
\begin{verbatim}
'new_descr' WHERE ean='111'; UPDATE users SET admin = 'true' WHERE username = 'Aragonez';
\end{verbatim}
Isto irá correr diretamente ao executarmos \textit{cursor.execute(query)}, o que representa grandes riscos de segurança.

Em \textbf{Psycopg}, a maneira correta de executar consultas SQL é da seguinte forma:
\begin{lstlisting}[language=python, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
query = "UPDATE product SET description=%s WHERE ean=%s"
data = (request.form["description"], request.form["ean"])
cursor.execute(query, data)
\end{lstlisting}

Outras recomendações básicas de segurança para evitar injeções SQL são:
\begin{itemize}
    \itemsep 0cm
    \item \textit{Forms} com \textit{method = POST} (e não \textit{GET});
    \item Instruções \textbf{PREPARED};
    \item SSL;
    \item Certificados.
\end{itemize}

\chapter{Teoria da Normalização}

Na conceção do modelo E-A, há certas decisões que se tomam que têm um grande impacto tanto ao nível lógico como ao nível físico e que se só são detetadas no modelo Relacionalm, obrigando por vezes a um processo iterativo de sucessivas reformulações do modelo E-A. Essas qualidades prendem-se com questões de \textbf{redundância e independência de atributos} das relações.

\section{Redundância e Independência de Atributos}

Em geral, a \textbf{redundância} consiste na existência de atributos em relações que se podem derivar diretamente de outros da mesma relação. Muitas vezes, esta redundância encontra-se ligada à inexistência de \textbf{dependência entre atributos}. Por isso, para além de causar desperdício de memória física, pode ter alguns efeitos indesejáveis, que se explicam de seguida.

\subsubsection{Anomalias de Inserção}

Por anomalias de inserção entende-se a impossibilidade de inserir um \textit{item} numa base de dados sem inserir igualmente outro item \textbf{potencialmente independente/não relacionado} com este.
\vspace{-0.3em}
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.6]{cap_norm/tabela_redundancia.png}
\end{figure}

Considere-se uma base de dados que só contém a relação $EMP\_DEPT(Ename, Ssn, Bdate, Dnumber, Dname, \\ Dmgr\_ssn)$ que indica que o funcionário com nome $Ename$, identificador $Ssn$, data de nascimento $Bdate$, morada $Address$ trabalha no departamento com número $Dnumber$, nome $Dname$ gerido pelo funcionário com identificador $Dmgr\_ssn$.\\
A inserção de um novo funcionário obriga a inserção dos dados do departamento no qual trabalha, levando potencialmente a entradas a \textbf{NULL} (indesejáveis). Mais ainda, a criação de um departamento ainda sem funcionários faria com que a informação relativa ao funcionário trabalhador ficasse por preencher. Desta forma, o atributo $Ssn$ (chave primária da relação!) estaria a \textbf{NULL}.

\subsubsection*{Anomalias de remoção}

Por anomalias de remoção entende-se a impossibilidade de remover um \textit{item} numa base de dados sem remover igualmente outro item \textbf{potencialmente independente/não relacionado} com este. \\

Considerando ainda a base de dados anterior, a remoção do de um trabalhador único num dado departamento apagaria por completo qualquer informação relativa ao mesmo.

\subsubsection*{Anomalias de atualização}

Por anomalias de atualização entende-se a impossibilidade de atualizar um \textit{item} numa base de dados sem atualizar igualmente outro item \textbf{potencialmente independente/não relacionado} com este. \\
Por exemplo, a mudança do identificador do gestor de um dado departamento ($Dmgr\_ssn$) ter-se ia que fazer tantas vezes quantos funcionários trabalhassem nesse departamento.

\subsubsection*{Anomalias de interrogação}

Dado que se usa mais memória nas tabelas manipuladas, verifica-se um maior tempo nas operações I/O e maior consumo de largura de banda, tornando obrigatoriamente as \textit{queries} mais ineficientes.

\section{Formas Normais}

Por forma a caracterizar o grau de de redundância, independência dos factos e facilidade de interrogação, existem \textbf{Formas Normais} - classes de relações que obedecem a determinadas condições ($kNF$ designa a $k$-ésima Forma Normal e $BCNF$ a Forma Normal de Boyce-Codd (\textit{Boyce-Codd Normal Form})). Verificam-se as seguintes inclusões:

\begin{equation}
    1NF \subseteq 2NF \subseteq 3NF \subseteq BCNF \subseteq 4NF ... 
\end{equation}

A maioria destas formas utiliza \textbf{Dependências Funcionais} entre atributos de uma relação como métrica de redundância.\\
Só serão abordadas as formas normais até à $BCNF$, pois esta é a última cujos critérios assentam sobre dependências funcionais.

\section{Dependências Funcionais}

\begin{definition}[Dependência Funcional - FD]
    Uma Dependência Funcional $X\rightarrow Y$ entre dois subconjuntos de atributos $X$ e $Y$ dos atributos $R$ de uma relação $r$ estabelece que (dados dois tuplos $t_1$ e $t_2$ de $r$):
    \begin{equation*}
        \forall t_1, t_2 \in r, \;t_1[X] = t_2[X] \Rightarrow t_1[Y] = t_2[Y]
    \end{equation*}
    Mais intuitivamente, os atributos de $Y$  \textbf{são função} de $X$. Diz-se que $X$ determina $Y$ ou que $X$ \textbf{determina funcionalmente} $Y$, sendo que $X$ é \textit{determinante} e $Y$ \textit{dependente}.
\end{definition} 

De notar que as dependências funcionais são propriedades um esquema de relação e não de um conjunto particular de registos. Desta forma, \textbf{é impossível} inferir dependências funcionais a partir de um conjunto de regitos, sendo unicamente possível provar que uma dada $FD$ não existe através de um contraexemplo desse mesmo conjunto de registos (e.g., a existência de dois conjuntos de atributos $Y$ associados a um mesmo conjunto de atributos $X$).

\subsection{Propriedades}

As seguintes propriedades designam-se de \textbf{Axiomas de Armstrong}:
\vspace{-0.3em}
\begin{align*}
    Y \subseteq X \Rightarrow X \rightarrow Y &&\text{(reflexividade)} \\
    X \rightarrow Y \Rightarrow XZ \rightarrow YZ, \: \forall Z  &&\text{(aumentação)} \\
    X \rightarrow Y \wedge Y \rightarrow Z \Rightarrow X \rightarrow Z &&\text{(transitividade)}
\end{align*}

\pagebreak
E as seguintes propriedades podem-se derivar dos axiomas:

\vspace{-0.3em}
\begin{align*}
    X \rightarrow X &&\text{(reflexividade)} \\
    X \rightarrow YZ \Rightarrow X \rightarrow Y \wedge X \rightarrow Z &&\text{(decomposição)} \\
    X \rightarrow Y \wedge X \rightarrow Z \Rightarrow X \rightarrow YZ &&\text{(união)} \\
    X \rightarrow Y \wedge A \rightarrow B \Rightarrow XA \rightarrow YB &&\text{(composição)} \\
    X \rightarrow Y \wedge YZ \rightarrow W \Rightarrow X \rightarrow W &&\text{(pseudo-transitividade)}
\end{align*}

\subsection{\textit{Attribute Closure}}

\begin{definition}[Fecho de um conjunto de atributos]
    Seja $X$ um subconjunto de atributos de um esquema relacional com um conjunto de dependências funcionais $F$. O fecho de $X$, $X^{+}$, consiste em todos os atributos que que \textbf{dependem funcionalmente} de $X$, isto é:
    \begin{equation*}
        X^{+} = \{ Z \in R: F \models \: X \rightarrow Z \}
    \end{equation*}
    i.e., os conjuntos dos atributos $Z$ de $F$ tais que a dependência $X \rightarrow Z$ pode ser inferida a partir dos axiomas de Armstrong e propriedades derivadas.
\end{definition}
\vspace{-0.3em}
\begin{algorithm}
    \caption{Algoritmo para calcular o \textit{attribute closure}}\label{alg:cap}
    \begin{algorithmic}
    \State $X^{+} \gets X$
    \Repeat
        \State $X_{old} \gets X^{+}$
        \ForEach {$Y \rightarrow Z \in F $}
            \If {$X^{+} \supseteq Y$}
                \State
                $X^{+} \gets  X^{+} \cup \{Z\}$
            \EndIf
        \EndFor
    \Until{$X^{+} = X_{old}$}
    \end{algorithmic}
 \end{algorithm}

Podemos então revisitar alguns conceitos à luz do \textit{attribute closure}.

\begin{definition} [Super-chave, chave candidate, chave primária]
    Dada uma relação $r$ com esquema $R$, e um subconjunto $K \subseteq R$, tem-se que:
    \begin{enumerate}
        \item $K$ é uma \textbf{super-chave} de $r(R)$ se $K \rightarrow R$, ou, \textit{analogamente}, $K^{+} = R$;
        \item $K$ é uma \textbf{chave candidata} de $r(R)$ se e só se  $K \rightarrow R \; \wedge \; \nexists(\alpha \subset K): \alpha \rightarrow R$ (i.e., uma super-chave minimal: nenhum subconjunto de $K$ determina funcionalmente $R$)
    \end{enumerate}
    Sendo que uma \textbf{chave primária} é uma qualquer chave escolhida do conjunto de chaves candididates de $R$.
\end{definition}

O seguinte conceito também revelar-se-á útil.

\begin{definition} [Dependência total]
    Sejam $X$ e $Y$ dois quaisquer conjuntos de atributos tais que $X \rightarrow Y$, diz se que $Y$ é \textbf{totalmente dependente} em $X$ se nenhum subconjunto próprio de $X$ determina funcionalmente $Y$, i.e., $\nexists(\alpha \subset X): \alpha \rightarrow Y$.
\end{definition}

\textit{Nota: uma chave candidata é uma super-chave na qual $R$ depende totalmente.}

\section{Descrição das Formas Normais}

\subsection{1ª Forma Normal}

\subsubsection*{Definição}

Uma relação encontra-se na 1ª forma normal se e só se:
\begin{itemize}
    \itemsep0cm
    \item[--] o domínio de todos os atributos contém apenas valores \textit{atómicos} (i.e., indivisíveis);
    \item[--] o valor num dado tuplo de uma relação tem de conter \textbf{um único valor} do domínio desse atributo. 
\end{itemize}

\subsubsection*{Normalização-$1NF$}

Uma relação que não se encontra na $1NF$ por apresentar domínios com valores não-atómicos pode ser normalizada ao transferir os campos do tuplo para uma nova relação, propagando a chave primária. Considere-se o seguinte exemplo com o atributo $Proj$ que é na verdade uma relação $Proj(Pnumber, Hours)$.

\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.6]{cap_norm/1nf_1.png}
    \hspace*{1em}
    \includegraphics[scale = 0.6]{cap_norm/1nf_2.png}
\end{figure}

Se relação que não se encontrar na $1NF$ por apresentar atributos com listas de valores, a normalização ocorre fazendo um registo para cada valor do atributo composto, passando a chave primária do registo a incorporar o novo atributo:

\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.4]{cap_norm/1nf_3.png}
\end{figure}

\textit{Nota: uma relação que não se encontra na 1º forma normal não pode sequer ser considerada uma relação.}

\subsection{2ª Forma Normal}

\subsubsection*{Definição}

Uma relação encontra-se na 2ª forma normal se e só se se encontrar na 1º forma normal e \textbf{todo o atributo não chave} (i.e., que não participa em nenhuma chave candidata) é \textbf{completamente dependente} em \textbf{atributos chave} (i.e., depende sempre totalmente de \textit{qualquer chave candidata}).

\subsubsection*{Normalização-$2NF$}

A conversão de uma relação na 1ª forma normal para a 2ª forma normal faz-se do seguinte modo:

\begin{itemize}
    \itemsep0cm
    \item[--] Para cada atributo não chave $R_n$ que \textbf{depende parcialmente} de um subconjunto de atributos chave de uma chave candidata $K$, $S \subseteq K$, retirá-lo da relação inicial $R$ e criar uma nova relação com chave primária $S$ e com esquema $(S, R_n)$. Mais formalmente, ocorre a seguinte decomposição da relação inicial $R$: 
    \[
        R \gets \{R \setminus R_n,\:  (S, R_n)\}
    \]
    afetando-se a cada relação resultante as FD's com cujos atributos constam nas relações resultantes.
\end{itemize}

Por exemplo, para a relação $R(\underline{A, B}, C, D)$ com chave primária $\{A, B\}$ e com dependências $AB \rightarrow C$ e $A \rightarrow D$, tem-se que $D$, não chave, depende parcialmente de uma chave (neste caso, da chave primária), dado que $A \rightarrow D$ e $A \subset \{A, D\}$. Assim, $R$ decompõe-se em duas relações: $R_1(\underline{A, B}, C)$, com dependência $AB \rightarrow C$, e $R_2(\underline{A}, D)$, om dependência $A \rightarrow D$.\\ 
\vspace*{0.3em}
\textit{Nota: Uma relação na 1NF cujas chaves possuem um só atributo encontram-se trivialmente na 2NF.}

\subsection{3ª Forma Normal}

\subsubsection*{Definição}

Uma relação encontra-se na 3ª forma normal se e só se se encontrar na 2º forma normal e se e só se \textbf{não há dependências entre atributos não-chave}.

\subsubsection*{Normalização-$3NF$}

A conversão de uma relação na 2ª forma normal para a 3ª forma normal faz-se do seguinte modo:

\begin{itemize}
    \itemsep0cm
    \item[--] Para cada atributo não chave $R_n$ que depende funcionalmente num conjunto de atributos não-chave $N$, retirá-lo da relação inicial $R$ e criar uma nova relação com chave primária $N$ e com esquema $(N, R_n)$. Mais formalmente, ocorre a seguinte decomposição da relação inicial $R$: 
    \[
        R \gets \{R \setminus R_n,\:  (N, R_n)\}
    \]
    afetando-se a cada relação resultante as FD's com cujos atributos constam nas relações resultantes.
\end{itemize}

Por exemplo, a relação $R(\underline{A}, B, C)$ com chave primária $A$ e com dependências $B \rightarrow C$ tem-se que $C$, não chave, depende de $B$, um atributo não chave. Assim, $R$ decompõe-se em duas relações $R_1(\underline{B}, C)$, com a FD $B \rightarrow C$, e $R_2(\underline{A}, B)$, com a FD $A \rightarrow B$.

\vspace*{0.3em}
\textit{Nota: Uma relação na 2NF que só possua um atributo naõ-chave encontra-se trivialmente na 3NF.}

\subsection{Forma Normal de \textit{Boyce-Codd}}

\subsubsection*{Definição}

Uma relação encontra-se na Forma Normal de \textit{Boyce-Codd} se e só se todo e qualquer atributo é totalmente dependente numa chave candidata:
\[
    \forall X \rightarrow Y, X \: \text{é chave candidata}
\]
excluindo obviamente as denominadas \textit{dependências triviais}, i.e., da forma $X \rightarrow Y$, para algum $Y \subseteq X$. \\
Quando uma relaçaõ está na $BCNF$, então \textbf{não apresenta qualquer redundância} detedada por dependências funcionais.\\
Antes de expormos a passagem para a $BCNF$, vamos introduzir alguns conceitos relativos à decomposição de relações.

\section{Decomposição de Relações}

Para além das formas normais, é desejável que as relações das bases de dados apresentem propriedades relativas a interrelações entre estas, propriedades estas que devem ser preservadas na decomposição de relações que permite a passagem para formas normais de grau superior. \\
Dado um esquema de relação $R = (A_1, A_2, ..., A_n)$, pretende-se obter uma decomposição $D = \{ R_1, ..., R_m\}$ que tenha as seguintes propriedades:

\subsubsection*{Propriedade da Preservação de Atributos}

Pretende-se que cada atributo $A_j$ figure em pelo menos uma relação $R_i$, i.e.:
\vspace{-0.3em}
\[
    \bigcup_{i = 1}^{m} R_i = R
\]

\subsubsection*{Propriedade da Preservação de Dependências}

Dado que cada dependência representa um constragimento sobre a base de dados, convém preservá-las numa decomposição, i.e., para toda a dependência funcional, tem de existir \textbf{pelo menos uma relação} que contenha todos os atributos dessa dependência (assim, não há perda de dependências ao afetá-las a relações recém criadas - ver exemplos acima). \\

%Mais formalmente, dado um conjunto de dependências $F$ de $R$, a projeção de $F$ em $R_i$, designada de $\pi_{R_i}(F)$, onde $R_i \subset R$, consiste no conjunto de dependências $X \rightarrow Y$ em $F^{+}$ tais que $X \cup Y \subseteq R_i$ (onde $F^{+}$ designa o \textit{fecho} de $F$, definido de forma análoga ao \textit{attribute closure}, sendo o conjunto de FD's deriváveis a partir das FD's de $F$). A esta operação dávamos-lhe informalmente o nome de afetação.\\%
%Diz-se que $D = \{ R_1, ..., R_m\}$ preserva as dependências em relação a $F$ se a união das projeções de $F$ em cada $R_i \in D$ é equivalente a $F$, i.e., $( \pi_{R_1}(F) \cup  ... \cup \pi_{R_m}(F))^{+} = F^{+}$%

\subsubsection*{Propriedade \textit{Lossless}}

Informalmente, diz-se que uma decomposição é \textit{lossless} (\textit{não-aditiva}) se a aplicação de um \textit{natural join} às relações relativas à decomposição resulta \textbf{exatamente} na relação inicial, não criando nenhum registo a mais.\\
Mais formalmente, uma decomposição $D = \{ R_1, ..., R_m\}$ de $R$ diz-se \textit{lossless} em relação a um conjunto de FD's $F$ de $R$ se, para qualquer instância de relação $r$ com esquema $R$, se tem  $\pi_{R_1}(r) \bowtie  ... \bowtie \pi_{R_m}(r) = r$, onde $\pi$ designa o operador de projeção da álgebra relacional.

\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.75]{cap_norm/lossy.png}
    \caption{Decomposição \textit{lossy}}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.75]{cap_norm/lossless.png}
    \caption{Decomposição \textit{lossless}}
\end{figure}

\begin{lemma} [Sucessão de decomposições \textit{lossless}]
    Se decomposições $D = \{R_1, R_2, ..., R_m\}$ e $D_i = \{Q_1, Q_2, ..., Q_m\}$ são \textit{lossless}, então a decomposição $D_2 = \{ R_1, R_2, ..., R_{i - 1}, Q_1, Q_2, ..., Q_m, R_{i + 1}, ...,  R_m\}$ é também \textit{lossless}.
\end{lemma}

\begin{theorem} [Teorema de \textit{Heath}]
    Uma decomposição $D = \{R_1, R_2\}$ é \textit{lossless} se pelo menos uma das duas dependências existir:
    \begin{enumerate}
        \item $(R_1 \cap R_2) \rightarrow (R_1 \setminus R_2)$
        \item  $(R_1 \cap R_2) \rightarrow (R_2 \setminus R_1)$
    \end{enumerate}
\end{theorem}

\textit{Nota: Mesmo que se consiga uma decomposição lossless, nem sempre se consegue que as decomposições preservem dependências. Contudo, não se considera que tal seja de grande gravidade, pois pode se verificar a validade das dependências recorrendo a operações de join em troca de um maior esforço computacional. Assim, o critério a ter na escolha de uma decomposição é: dada uma decomposição obrigatoriamente lossless, escolhar aquela que perde o menor número de dependências.} \\

\textit{Nota: Pode-se verificar que as decomposições feitas na normalização-1nf, normalização-2nf e normalização-3nf são lossless - basta atentar na forma da decomposição resultante e aplicar alguma álgebra de conjuntos. Contudo, não é garantido que as mesmas preservem todas as dependências.}

\section{Conversão para a \textit{BCNF}}

O seguinte algoritmo garante a conversão de uma \textbf{qualquer relação $R$} (mesmo sem estar na $2NF$) para a $BCNF$ através de uma decomposição $D$ \textit{lossless}.

\begin{algorithm}
    \caption{Algoritmo de conversão para a $BCNF$}\label{alg:cap}
    \begin{algorithmic}
    \State $D \gets \{R\}$
    \While{$\exists S \in D \: \text{not in BCNF}$}
        \State $Q \gets \{S \in D : \: S \: \text{not in BCNF}\}$
        \State $(X \rightarrow Y) \gets \{(X \rightarrow Y) \in Q : \: X \rightarrow Y \: \text{violates BCNF}\}$
        \State $D \gets (D \setminus Q) \cup \{(Q \setminus Y), (X \cup Y)\}$
    \EndWhile
    \end{algorithmic}
 \end{algorithm}

 A última instrução do bloco \textit{while} corresponde a uma decomposição \textit{lossless} pelo teorema de \textit{Heath}: $Q \gets \{(Q \setminus Y), (X \cup Y)\}$ . A propriedade da sucessão de decomposições \textit{lossless} juntamente com o facto de que cada iteração diminui em pelo menos um atributo duas relações de $D$ e que, no limite, relações com apenas 2 atributos não geram quaisquer redundância, garante que o algoritmo converte a relação para a $BCNF$ em tempo $O(2^{|R|})$. \\

\textit{Nota: Existe um algoritmo que gera uma decomposição tanto lossless como preservadora de dependências para conversão para a 3NF}



\chapter{Índices}

Quando se pretende procurar registos numa tabela, uma abordagem passaria por ler toda a tabela e todos os seus conteúdos. Contudo, tal seria demasiado ineficiente para \textit{queries} que retornam poucos resultados. \\
Desta forma, recorrem-se a \textbf{índices}, que são ficheiro auxiliares que, dada uma \textbf{chave de procura} (conjunto de atributos de uma relação), permitem obter de forma mais rápida informação sobre registos (como o seu endereço em memória ou até o(s) próprio(s) registo(s) - no caso em que a chave de procura não é uma chave primário).\\
A forma mais rudimentar de índice consiste num ficheiro com entradas dispotas \textbf{sequencialmente} e ordenadas pela \textbf{chave de procura}. Por forma a localizar uma dada chave de procura, realiza-se procura binária sobre a tabela. Antes de discutir formas mais sofisticadas de índices, apresentam-se conceitos básicos sobre índices. De notar que as diferentes características existem ortogonalmente (i.e., todas as combinações são admissíveis, \textbf{excepto quando indicado explicitamente}).

\section{Conceitos básicos}

\subsection{Índices ordenados e não ordenados}
 
Dependendo de como os registos a que se referem se encontram fisicamente dispostos em memória, os índices podem-se classificar como:
\begin{itemize}
    \item[--] \textbf{Índice ordenado/primário/\textit{clustering}}, se os registos se encontram ordenados em memória igualmente por ordem da chave do índice. Normalmente, chaves primárias como chaves de índice dão origem a índices \textit{clustering}, daí a terminologia. Por exemplo, um índice ordenado cuja chave de procura fosse o \textit{id} do instrutor (coluna da esquerda), seria um índice primário, dada a disposição dos registos em memória.
    \begin{figure}[H]
        \centering
        \includegraphics[scale = 0.75]{cap_indices/indice_primario.png}
        \caption{Ficheiro com registos da relação \textit{instrutor}}
    \end{figure}
    \item[--] \textbf{Índice não ordenado/secundário/não \textit{clustering}}, se a chave do índice especifica uma ordem diferente da ordem sequencial do ficheiro de registos.
    \begin{figure}[H]
        \centering
        \includegraphics[scale = 0.75]{cap_indices/indice_secundario.png}
        \caption{Índice secundário sobre o nome do departamento}
    \end{figure}
\end{itemize}

Índices \textit{clustering} são geralmente \textbf{mais vantajosos} que índices não \textit{clustering}, pois, se quisermos obter vários registos com chaves de procura adjacentes, é suficiente ter um ponteiro para o primeiro registo, obtendo os registos da memória sequencialmente avançado simplesmente com esse ponteiro. Nos registos não \textit{clustering}, é possível que o próximo registo esteja num bloco de disco diferente, o que induz maior latência no acesso à memória. Quando se pretende obter \textbf{um único registo}, ambos os índices apresentam performances idênticas. \\

No seguimento desta disussão, é importante referir os tipos de organização física usados pelos SGBD:
\begin{itemize}
    \itemsep0cm
    \item[--]\textbf{Heaps}, no qual novos registos são colocados no primeiro espaço livro (leva a fragmentação a longo prazo);
    \item[--]\textbf{Sorted Files}, no qual novos registos os registos são ordenados segundo o valor da sua chave primária;
    \item[--] \textbf{Hashed Files}, no qual os fiheiros são organizados em \textit{buckets} de acordo com uma dada função de \textit{hash};
\end{itemize}

\subsection{Índices Densos/Esparsos}

Os índices podem ainda ser:

\begin{itemize}
    \item[--] \textbf{Densos}, se existe uma correspondência 1:1 entre as entrada do índice e registos da tabela.
    \begin{figure}[H]
        \centering
        \includegraphics[scale = 0.60]{cap_indices/indice_denso.png}
        \caption{Índice denso}
    \end{figure}
    \item[--] \textbf{Esparsos}, se existe uma correspondência 1:N entre uma entrada do índice e registos da tabela, i.e., só existem entradas no índice para alguns registos da tabela - este tipo de organização só é possível em \textbf{índices \textit{clustering}}. Mais especificamente, para localizar um dado registo, determina-se a entrada no índice com \textbf{a maior chave menor ou igual à chave do registo a localizar}. A partir do ponteiro obtido, faz-se um procura sequencial até ao registo pretendido.
    \begin{figure}[H]
        \centering
        \includegraphics[scale = 0.60]{cap_indices/indice_esparso.png}
        \caption{Índice esparso}
    \end{figure}
\end{itemize}

De acordo com as definições anteriores, há um \textit{tradeoff} entre espaço e tempo nas duas variantes anteriores: enquando que um índice esparso ocupa menos espaço em memória, um índice denso permite localizar mais rapidamente registos, ao evitar procura linear sobre as tabelas de registos.\\
Contudo, atendendo a que o principal \textit{overhead} na execução de uma \textit{query} se prende com a transferência de blocos de e para disco, tem-se que, trazido um bloco para memória, o tempo para pesquisar sobre o bloco é negligenciável. Assim, se cada entrada num índice esparso apontar exatamente para o início de \textbf{bloco de índices}, tem-se \textbf{índices densos são a opção preferencial}.

\subsection{Índices Multinível}

Se o índice não for pequeno o suficiente para caber em memória principal, a procura de uma entrada no índice pode levar a vários acessos ao disco.\\
Para lidar com este problema, os \textbf{índices multinível} constroem um índice exterior \textbf{esparso} sobre o índice original, agora denominado de índice interior (de notar que o índice interior está ordenado por hipótese, permitindo um índice esparso). Cada uma destas tabelas de índices ocupa normalmente \textbf{um bloco de disco}, sendo que o índice exterior é pequeno o suficiente por forma a poder ser \textbf{mantido em memória principal}.
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.50]{cap_indices/indice_multinivel.png}
    \caption{Índice Multinível com 2 níveis}
\end{figure}
Para localizar um índice, faz-se procura binária no índice exterior para encontrar a entrada com \textbf{a maior chave menor ou igual que a chave do registo pretendido}. Daqui se obtém um ponteiro para um bloco do índice interior, que é assim varrido à procura da chave pretendida (se o índice interior for denso) ou da maior chave menor ou igual à pretendida (se o índice interior for esparso). \\
De notar que é possível adicionar índices interiores sucessivos se a tabela do índice exterior não couber em memória, originando estruturas com mais do que dois níveis.\\
Assim, o número de leituras de disco é no pior caso $N$, onde $N$ é o número de níveis do índice multinível - tendencialmente melhor que o limite $\lceil\log_2(b)\rceil$ que se obteria pela pesquisa binária anterior.

\subsection{Índices em múltiplas chaves}

Quando se pretende fazer seleção de registos com base em múltiplos atributos, pode ser conveniente possuir um índice cuja chave é composta por múltiplos atributos.\\
Desta forma, cada chave do índice é da forma $(a_1, ..., a_n)$ e as entradas do índice encontram-se ordenadas por \textbf{ordem lexicográfica} das suas chaves, i.e., $(a_1, b_1) < (a_2, b_2)$ se e só se $a_1 < a_2$ ou $a_1 = a_2$ e $b_1 < b_2$.

\section{Manutenção de índices}

Apesar da aceleração que proporciona, a utilização de índices acarreta custos de manutenação, pois há que manter uma estrutura de índices coerente perante a inserção, remoção e atualização de registos nas tabelas. Como a atualização pode ser vista como um remoção seguida da inserção de um registo diferente do inicial, apenas se abordam os primeiros dois casos.

\subsubsection{Inserção}

No caso de \textbf{índices densos}, insere-se uma entrada no índice com a nova chave.
Se o índice for \textbf{esparso} e se a novo registo obriga a criação de um novo bloco em disco, então insere-se uma entrada no índice com a nova chave.

\subsubsection{Remoção}

No caso de \textbf{índices densos}, remove-se a entrada no índice correspondente à chave do registo a apagar.
Se o índice for \textbf{esparso}, há que ter em conta dois casos:
\begin{itemize}
    \itemsep 0cm
    \item[--] se a entrada a apagar era a única com a sua chave de procura, então a substitui-se a chave da entrada do índice pela próxima chave; só se apaga a entrada se a próxima chave já possuir uma entrada.
    \item[--] se a entrada no índice correspondente apontar exatamente para o registo a apagar, então essa entrada é atualizar por forma a  apontar para o próximo registo com a mesma chave de procura.
\end{itemize}

\section{Tipos de índices}

Para além da organização sequencial inicialmente apresentada, existem os seguintes tipos de índices, que apresentam diversas vantagens sobre esta:

\subsection{Índices $B^{+}-tree$}

Uma $B^{+}-tree$ consiste numa árvora balanceada (i.e., qualquer caminho da raíz até uma folha tem o mesmo comprimento) composta por nós com $\lceil\frac{n}{2}\rceil$ a $n$ filhos, onde $n$ é um parâmetro fixo da árvore (se o nó for uma folha, substitui-se $n$ por $n - 1$ nas condições anteriores). \\
Cada nó de uma $B^{+}-tree$ contém $m - 1$ chaves de procura $K_1, K_2, ..., K_{m - 1}$ e $m$ ponteiros $P_1, P_2, ..., P_{m}$, onde $m \le n$ e as chaves se encontram por \textbf{ordem crescente}.
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.50]{cap_indices/no_btree.png}
    \caption{Nó de uma $B^{+}-tree$}
\end{figure}

Nos \textbf{nós folha}, cada ponteiro $P_i$ ($i < m$) aponta para um registo em memória, enquanto o ponteiro $P_m$ aponta para o próximo nó folha, por forma a facilitar varrimentos sequenciais de registos sem ter que percorrer a árvore toda a partir do topo.\\
Nos \textbf{nós interiores}, se possuirem $m - 1$ chaves de índice, cada ponteiro $P_i$ ($i \le m$) aponta para outro nó que é raíz de uma subárvore com chaves de procura \textbf{menores} que $K_i$ e \textbf{maiores ou iguais} que $K_{i - 1}$. Notar que o primeiro ponteiro, $P_1$ aponta para uma subárvore com registos com chaves menores que $K_1$, e o último ponteiro, $P_{m}$, aponta para registos com chaves maiores ou iguais que $K_{m - 1}$.\\
Se $i > m$ então o ponteiro aponta para \textbf{NULL}.

\begin{figure}[H]
    \centering
    \includegraphics[scale = 1]{cap_indices/btree.png}
    \caption{Exemplo de uma $B^{+}-tree$}
\end{figure}

Dado que, para uma tabela com $N$ registos, a altura de uma árvore é $O(\log_{\lceil\frac{n}{2}\rceil}(N))$, \textit{queries} de seleção com base em igualdade são muito eficientes quando há índices $B^{+}-tree$: basta percorrer uma árvore com altura logarítmica em $n$ desde a raíz até ao nó folha pretendido. \\
Ademais, \textbf{\textit{range queries}} (i.e., procura de valores com chave num intervalo $[\min, \max])$ também são eficientes: basta percorrer a árvore à procura da entrada com chave $\min$ e fazer um varrimento sequencial usando os últimos ponteiros de cada nó folha até à última chave com valor $\max$. \\
Contudo, dada a restrição no número de chaves em cada nó, operações de inserção e remoção induzem um \textit{overhead} adicional, fazendo com que sejam também $O(\log_{\lceil\frac{n}{2}\rceil}(N))$.
%(\textbf{Não avaliado}) A inserção de um registo pode fazer com que cada nó possua mais que $n$ ponteiros; nesse caso, há que criar novos nós, criando novos ponteiros no nível acima, que podem novamente ficar cheios, etc... . Analogamente, a remoção pode fazer com ue cada nó possua menos que $\lceil\frac{n}{2}\rceil$ ponteiros; nesse caso ou se transferem todos os ponteiros para o nó à esquerda, se tiver capacidade, ou se transferem ponteiros do nó da esquerda por forma a que o número de ponteiros do nó prefaça de novo $\lceil\frac{n}{2}\rceil$; se o nó a apagar tiver a primeira chave de um nó, pode ser necessário apagar essa chave em todos os nós no caminho até à raíz.


\subsection{Índices \textit{Hash}}

Num índice \textit{Hash}, as entradas do índice estão organizadas em \textit{buckets}, que na prática corresponde a uma lista ligada de registos (quando o índice está em memória principal), ou lista ligada de blocos (quando está em disco). Dado um registo com chave $K_i$, o endereço do \textit{bucket} no qual esse registo vai ser inserido obtém-se por aplicação de uma função de \textit{hash}, $h(K_i)$. Por norma, a resolução de colisões faz-se por encadeamento externo, ou, no contexto de índices, \textbf{\textit{overflow chaining}}.\\
Índices \textit{Hash} são particularmente úteis em \textit{queries} de igualdade, não sendo no entando apropriadas para \textit{queries} de \textit{range}.

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.60]{cap_indices/hash_index.png}
    \caption{Exemplo de um índice \textit{Hash}}
\end{figure}

Um dos principais problemas associadas a este tipo de índices consiste no \textit{bucket overflow}: quando o número de \textit{buckets} não é suficiente para o número de registos da tabela ou quando certos \textit{buckets} recebem muito mais registos que outros, há que encadear vários \textit{buckets} que na verdade estão associados à mesma chave de dispersão, resultando em piorias na procura de registos. \\
Por forma a contrariar este problema, em vez de se fazer \textit{hashing} estático (i.e., número de \textit{buckets} é fixo), pode-se fazer  \textit{hashing} dinâmico, adaptando-se de forma incremental o número de \textit{buckets} ao número de registos que existem na tabela em cada momento.

\subsection{Índices \textit{Bitmap}}

Um \textbf{índice \textit{bitmap}} num atributo $A$ de uma relação $r$ consiste num \textit{bitmap} para cada valor que $A$ pode tomar. Assim, se $A$ tomar valores em $(v_1, ..., v_n)$, existem $n$ bitmaps $b_i = (b_{i1}, ..., b_{iN})$, onde $N$ é o número total de registos na tabela. O significado destes \textit{bitmaps} é o seguinte: se $b_{ij} = 1$, então o registo número $j$ tem o atributo $A$ com valor $v_i$. \begin{figure}[H]
    \centering
    \includegraphics[scale = 0.60]{cap_indices/indice_bitmap.png}
    \caption{Exemplo de um índice \textit{Bitmap}}
\end{figure}

Os índices \textit{bitmap} revelam-se vantajosos quando as tabelas não são muito grandes e há necessidade de fazer seleções complexas com base em certos atributos. Por exemplo, se se quer determinar os registos com género masculino e com nível de rendimento $L2$ ou $L3$, basta aplicar a expressão lógica aos bitmaps correspondentes. No bitmap resultante, se entrada $i$ está a 1, então o registo $1$ satisfaz a \textit{query}, sendo trivial a partir daí saber \textit{exatamente} quais os blocos a aceder sem ter que fazer uma procura sequencial (notar que isto só é vantajoso em \textit{queries} bastante seletivas, como se vai ver mais à frente).
\pagebreak


\section{Índices em SQL}

Embora o SQL-92 não defina sintaxe para criação de índices, esta operação é suportada pelos SGBD's atuais:

\begin{lstlisting}[language=SQL, morekeywords={CALL, DECLARE, PROCEDURE, IF}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE INDEX index_name ON table_name [Type] (column list)
\end{lstlisting}

Onde \textit{Type} corresponde aos tipos de índice anteriores (notar que não é possível fazer um índice \textit{Hash} em mais do que um coluna). A não especificação de \textit{Type} leva a uma escolha \textit{default}. \\
Por omissão, criam-se índices sobre \textit{primary keys}, dada a necessidade de impor a verificação da restrição da chave primária de forma eficiente. Embora nem sempre se criem índices sobre \textit{foreign keys}, é boa prática fazê-lo, especialmente na presença das cláusulas \textit{ON DELETE CASCADE} ou \textit{ON UPDATE CASCADE}.

\subsection{Seletividade de uma \textit{query}}

Antes de expor em que casos é que é vantajoso e útil criar índices, vamos introduzir o conceito de \textbf{seletividade}.\\
Pela discussão anterior, um índice é tão mais útil quanto mais diminuir a necessidade de trazer blocos para memória. Dada uma \textit{query}, a sua \textbf{seletividade} está relacionada com a proporção de registos que serão incluídos na resposta (i.e., uma query é \textbf{tão mais seletiva} quanto menos registos fizerem parte da resposta). Seja $s$ essa proporção, e seja $n$ o \textbf{número de registos que cabem num bloco de disco}. Tem-se:

\begin{itemize}
    \itemsep0cm
    \item[--] A probabilidade de um dado registo não ser incluído na resposta à query é $1 - s$;
    \item[--] A probabilidade de um bloco não possuir qualquer registo que vai ser incluído na resposta à query é $(1-s)^n$ (assumindo uma distrbuição uniforme dos registos com respostas pelos blocos);
    \item[--] A probabilidade de um bloco possuir pelo menos um registo que vai ser incluído na resposta à query (sendo por isso trazido para memória) é $1 - (1-s)^n$.
\end{itemize}
Atendendo à última expressão, tem-se que um índice serão tão mais útil quando menos registos houver por bloco e quão mais seletiva for a query (i.e., menor $s$).

\subsection{\textit{Queries} que dispensam o uso de índices}

\textit{Queries} que não fazem qualquer tipo de \textit{join}, agrupamento, \textit{sorting} ou filtragem dispensam o uso de índices. Exemplo:

\begin{lstlisting}[language=SQL, morekeywords={CALL, DECLARE, PROCEDURE, IF}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT vcName,ntAge FROM tblEmployee1 
    UNION ALL
SELECT vcName,ntAge FROM tblEmployee2
\end{lstlisting}

Também dispensam o uso de índices \textbf{adicionais} \textit{queries} que fazem filtragens/\textit{joins} sobre as chaves primárias de relações (pois já existem índices para estas).

\subsection{\textit{Queries} onde é conveniente usar índices}

Quando há necessidade de remoção de duplicados, há necessidade de ordenar registos, sendo por isso útil criar um índice $B^{+}-tree$ sobre os atributos (no caso seguinte, sobre (\textit{vcName}, \textit{ntAge})).

\begin{lstlisting}[language=SQL, morekeywords={CALL, DECLARE, PROCEDURE, IF}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT vcName,ntAge FROM tblEmployee1 
    UNION
SELECT vcName,ntAge FROM tblEmployee2
\end{lstlisting}

Quando há seleções com base em igualdade, deve se criar um índice \textit{Hash} sobre o atributo; se houver seleções com base em comparação, esse índice deve ser $B^{+}-tree$. Quando existem vários comparações, como heurística, devem ser postos em primeiro lugar no índice os atributos referentes às condições de igualdade (que é uma operação tendencialmente mais seletiva que a comparações de desigualdade). 

\begin{lstlisting}[language=SQL, morekeywords={CALL, DECLARE, PROCEDURE, IF}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT * FROM tblEmployee WHERE b=5 AND c>10 AND d=15 AND e<=20
\end{lstlisting}

Assim, no exemplo acima, qualquer um dos índices é aceitável:

\begin{lstlisting}[language=SQL, morekeywords={CALL, DECLARE, PROCEDURE, IF}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
CREATE INDEX idx ON tblEmployee(b,d,c)
CREATE INDEX idx ON tblEmployee(b,d,e)
CREATE INDEX idx ON tblEmployee(d,b,c)
CREATE INDEX idx ON tblEmployee(d,b,e)
\end{lstlisting}

De qualquer forma, é útil realizar uma \textbf{análise prévia da seletividade}, contando, para cada atributo, o número de valores diferentes.\\

\textbf{Nota Importante}: Apenas é possível criar um índice por tabela! \\

Também em condições sem prefixo é útil criar índices, pois há na verdade uma comparação alfabética:

\begin{lstlisting}[language=SQL, morekeywords={CALL, DECLARE, PROCEDURE, IF}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT vcName,ntAge FROM tblEmployee WHERE vcName LIKE 'Greg%'
\end{lstlisting}

\subsection{\textit{Index-Only Plans}}

Se as \textit{queries} referenciarem atributos que são partes de índices, é possível que a query seja respondida apenas com informação presente em índices. Por exemplo, um índice sobre $E(dno, sal)$, permite responder à seguinte \textit{query}:

\begin{lstlisting}[language=SQL, morekeywords={CALL, DECLARE, PROCEDURE, IF}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT E.dno, MIN(E.sal) FROM Emp E
GROUP BY E.dno
\end{lstlisting}

\section{Otimização e Processamento de \textit{queries}}

Relembremos as etapas do processamento de uma \textit{query}:

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.5]{cap1/arquitetura.png}
    \caption{Processamento de uma \textit{query}}
\end{figure}

Por forma a avaliar uma \textit{query}, não é suficiente convertê-la numa expressão de álgebra relacional. É necessário também anotá-la com instruções que especifiquem exatamente como avaliar cada instrução, formando assim um \textbf{plano de execução}, que pode ser dado como input ao motor de execução da \textit{query}.\\
O plano de execução é tendencialmente um plano \textbf{ótimo}. Por forma a estimar o custo de cada operação, o SGBD mantém estatísticas sobre cada relação, nomeadamente:

\begin{itemize}
    \itemsep0cm
    \item[--] $n_r$, o número de tuplos da relação $r$;
    \item[--] $b_r$, o número de bloco que contêm tuplos da relação $r$;
    \item[--] $l_r$, o tamanho de cada tuplo da relação $r$;
    \item[--] $f_r$, o número de tuplos da relação $r$ que cabem num bloco;
    \item[--] $V(A, r)$, o número de valores distintos que aparecem na relação $r$ no atributo $A$;
\end{itemize}

Considera-se ainda o seguinte \textbf{modelo de custo}: dado um custo de transferência de um bloco de $T_t$ segundos, um custo de acesso ao bloco de $T_s$ segundos, uma operação que transfira $b$ blocos e que execute $S$ acessos aleatórios (i.e., não sequenciais), terá um custo de 
\[
    b \cdot t_T + S \cdot t_S
\]

Vamos agora olhar para os diferentes tipos de operação à luz deste modelo de custo.

\subsection{Seleções}

\subsubsection*{Seleções sem índice}

Na ausência de índice, assumindo contiguidade dos blocos em memória, há que contabilizar o tempo de acesso ao bloco, mais um tempo de transferência por cada bloco trazido para memória. No caso da igualdade na chave, pode-se terminar a pesquisa quando o(s) registo(s) pretendidos são encontrados, o que acontece em média a meio de cada bloco.

\begin{table}[H]
    \centering
    \begin{tabular}{c|c}
       Algoritmo                              & Custo  \\ \hline
      Pesquisa Linear                        &   $t_S + b_r \cdot t_T$     \\ \hline
     Pesquisa Linear com igualdade na chave &     $t_S + (\frac{b_r}{2}) \cdot t_T$ (caso médio)  \\ \hline
    \end{tabular}
\end{table}

\subsubsection*{Seleções com índice}

Estas operações também são frequentemente denominadas de \textit{index scans}. \\
Seja $h_i$ a altura da árvore $B^{+}-tree$ e $n$ o número de registos trazidos para memória. Nos casos abaixo, a igualdade numa chave/não-chave determina se é necessário analisar a totalidade dos blocos apontado por cada entrada no índice. Índices não \textit{clustering} fazem com que o acesso a cada bloco acarrete um custo de $t_S$ adicionais (pois os registos podem se encontrar espalhados na memória). A comparação é semelhante à igualdade numa não-chave.

\begin{table}[H]
    \centering
    \begin{tabular}{c|c}
       Algoritmo                              & Custo  \\ \hline
      Index \textit{clustering}, índice $B^{+}-tree$, igualdade na chave                        &  $(h_i + 1) \cdot (t_T + t_S)$     \\ \hline
      Index \textit{clustering}, índice $B^{+}-tree$, igualdade numa não-chave                        &  $h_i \cdot (t_T + t_S) + t_S + b \cdot t_T$  \\ \hline
      Index \textit{não clustering}, índice $B^{+}-tree$, igualdade na chave                        &  $(h_i + 1) \cdot (t_T + t_S)$     \\ \hline
      Index não \textit{clustering}, índice $B^{+}-tree$, igualdade numa não-chave                        &   $(h_i + n) \cdot (t_T + t_S)$  \\ \hline
      Index \textit{clustering}, índice $B^{+}-tree$, comparação                        & $h_i \cdot (t_T + t_S) + t_S + b \cdot t_T$     \\ \hline
      Index não \textit{clustering}, índice $B^{+}-tree$, comparação                        &    $(h_i + n) \cdot (t_T + t_S)$  \\ \hline
    \end{tabular}
\end{table}

\subsection{Ordenação}

Dada a quantidade de registos a ordenar, raramente a operação de ordenação se realizar totalmente em memória.\\
Dada uma memória na qual cabem $M$ blocos, o \textbf{External Sorting} divide os $b_r$ blocos com registos em $N$ \textit{runs} (etapas) com $\lceil\frac{b_r}{M}\rceil$ blocos, ordenando-as individualmente.\\
De seguida, ocorre um \textbf{merge} das $N$ vias (o \textit{mergesort} como o conhecemos fá-lo em 2 vias), diminuindo o número de \textit{runs} em $M - 1$ em cada \textit{pass}.
%(curiosidade: para tal, escolhe-se $b_b$ blocos de cada \textit{run}, fazendo-se merge de $\lfloor\frac{M}{b_r}\rfloor - 1$ runs de cada vez).
\vspace{-1em}
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.35]{cap_indices/external_sort.png}
    \caption{\textit{External Sort}}
\end{figure}

Com certas otimizações, é possível provar que o número de acessos a blocos num \textit{External Sort} é:
\[
    b_r(2 \log_{\lfloor\frac{M}{b_r}\rfloor - 1}(b_r / M) + 1)
\]

e o número de acessos aleatórios em disco é (sabendo, por otimização, se trazem $b_b$ de cada run para se fazer merge, em vez de um só bloco):

\[
    2 \lceil b_r /M\rceil + \lceil b_r / b_b \rceil(2 \log_{\lfloor\frac{M}{b_r}\rfloor - 1}(b_r / M) - 1)
\]

\subsection{\textit{Joins}}

\subsubsection*{\textit{Nested-Loop Join}}

Dadas relações $r$ e $s$ com $n_r$ e $n_s$ tuplos, este tipo de join apresenta $n_r \cdot b_s + b_r$ acessos a blocos e $n_r + n_s$ acessos aleatórios, sendo a forma mais primitiva de se fazer \textit{join}.

\begin{algorithm}
    \caption{\textit{Nested-Loop Join}}\label{alg:cap}
    \begin{algorithmic}
    \ForEach {tuple $t_r$ in $r$}
        \ForEach {tuple $t_s$ in $s$}
        \State test pair $(t_r , t_s)$ to see if they satisfy the join condition $\theta$
        \State if they do, add $tr \cdot ts$ to the result;
        \EndFor
    \EndFor
    \end{algorithmic}
 \end{algorithm}

\subsubsection*{\textit{Block Nested-Loop Join}}

Por forma a diminuir a frequência dos acessso aleatórios a disco, este tipo de \textit{join} procede-se bloco a bloco (anteriormente, testava-se um tuplo de $r$ contra \textit{todos} os blocos de $s$). Este tipo de join apresenta $b_r \cdot b_s + b_r$ acessos a blocos e $b_r + b_s$ acessos aleatórios, o que representa uma melhoria significativa em relação ao caso anterior.

\begin{algorithm}
    \caption{\textit{Block Nested-Loop Join}}\label{alg:cap}
    \begin{algorithmic}
    \ForEach {block $B_r$ of $r$}
        \ForEach {block $B_s$ of $s$}
            \ForEach {tuple $t_r$ in $B_r$}
                \ForEach {tuple $t_s$ in $B_s$}
                    \State test pair $(t_r , t_s)$ to see if they satisfy the join condition $\theta$
                    \State if they do, add $tr \cdot ts$ to the result;
                \EndFor
            \EndFor
        \EndFor
    \EndFor
    \end{algorithmic}
 \end{algorithm}

\subsubsection*{\textit{Hash Join}}

Dada uma função de \textit{h} que mapeia atributos sobre os quais se faz \textit{join} para $\{0, 1, ..., n_h \}$.\\
Sejam $\{r_0, r_1, ..., r_{n_h}\}$ as partições dos tuplos de $r$ tais que cada tuplo $t_r$ de $r$ é colocado em $r_i$ se:
\[
    i = h(t_r([\text{Atributos de Join}]))
    \]
sendo as partições $\{s_0, s_1, ..., s_{n_h}\}$ são definidas analogamente. \\
O funcionamento do \textit{Hash Join} baseia-se na seguinte observação: se $t_r$ e $t_s$ satisfazem a condição de \textit{join}, então são ambos \textit{hashed} para o mesmo valor $i$. Desta forma, só é necessário comparar tuplos de $r$ em $r_i$ com tuplos de $s$ em $s_i$. \\
Por questões de otimização, para cada $i$, constroi-se uma tabela $Hash$ com os tuplos de $s_i$ com uma função de \textit{hash} diferente da anterior. O obietivo é evitar que todos os registos dentro de um mesmo balde $i$ sejam tidos em conta para fazer \textit{join} com um registo de $r$.

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.50]{cap_indices/hash_join.png}
    \caption{\textit{Hash Join}}
\end{figure}

\subsection{Otimização de \textit{Queries} baseadas em heurísticas}

Por vezes, o número de planos gerados para cada \textit{query} é demasiado grande, originando a um esforço computacional que é agravado pelo cálculo dos custos de cada operação.\\
Desta forma, dadas de associatividade, comutatividade e distribuição da álgebra relacional que não são aqui referidas, procede-se simplesmente à simplificação da expressão algébrica por forma a que \textbf{operações de seleção e de projeção ocorram o mais cedo possível na computação}. \\
O \textit{rational} desta decisão prende-se com a diminuição da quantidade de informação a processar o mais cedo possível, descartando colunas e registos das tabelas que não serão usados. (Note-se que nem sempre isso ocorre: se existir um seleção depois de um join e houver um índice sobre atributos do join, pode ser prejudicial adiantar a operação de seleção).

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.8]{cap_indices/otimizacao_expr.png}
    \caption{Otimização da expressão algébrica por heurísticas}
\end{figure}
\vspace{-0.5em}
\subsection{Análise de planos de execução no Postgres}

Através do comando:
\begin{lstlisting}[language=SQL, morekeywords={CALL, DECLARE, PROCEDURE, IF, EXPLAIN, ANALYSE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
EXPLAIN ANALYSE 
[query]
\end{lstlisting}

é possível obter uma \textbf{árvore correspondente ao plano de execução}. Se for pretendido obter \textbf{dados reais} relativos à execução da \textit{query}, pode-se envolter o comando numa transação:

\begin{lstlisting}[language=SQL, morekeywords={CALL, DECLARE, PROCEDURE, IF, EXPLAIN, ANALYSE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
BEGIN TRANSACTION
EXPLAIN ANALYSE 
[query]
ROLLBACK
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.6]{cap_indices/explain.png}
    \caption{Resultado do comando \textit{EXPLAIN ANALYSE}}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.5]{cap_indices/arvore_explain.png}
    \caption{Árvore de execução correspondente}
\end{figure}

O termo \textit{cost} diz respeito ao custo estimado da operação, sendo \textit{actual time} o custo real; \textit{width} diz respeito ao tamanho de cada tuplo, \textit{rows} ao número de registos analisados e \textit{loops} o número de vezes em que se iterou sobre um dado conjunto de registos. Descreve-se agora o significado de alguns dos procedimentos que se podem obter:

\begin{itemize}
    \itemsep0cm
    \item[--] \textbf{SeqScan}: um varrimento sequencial da tabela;
    \item[--] \textbf{IndexScan}: varrer o índice, ir de seguida à memória.
    \item[--] \textbf{IndexOnlyScan}: varrer unicamente o índice (acontece em \textit{queries} que manipulam/acedem a atributos de um dado índice);
    \item[--] \textbf{Bitmap Scan}: varrer o índice e construir um \textit{bitmap} dos registos que obedecem ao critério de filtragem.
    \item[--] \textbf{NestLoop/HashJoin}: falados anteriormente;
    \item[--] \textbf{Merge Join}: tipo de merge que se faz em tempo linear quando ambos os conjuntos de tuplos estão ordenados;
    \item[--] \textbf{Lateral Join}: \textit{Join} contra \textit{table expressions};
    \item[--] \textbf{Semi Join}: para \textit{outer joins};
    \item[--] \textbf{Anti Join}: \textit{joins} exclusivos (e.g., NOT IN...);
    \item[--] \textbf{GroupAggregarte}: agregação normal;
    \item[--] \textbf{HashAggregarte}: agregação em memória baseada em funções de \textit{hash};
    \item[--] \textbf{CTEScan}: junção de uma CTE à \textit{query} principal;
    \item[--] \textbf{SubqueryScan}: idem, mas para \textit{subqueries};
    \item[--] \textbf{Materialize}: criar um conjunto de registos em memória a partir de uma \textit{query};
    \item[--] \textbf{Append}: usado na junção de conjuntos de registos.
\end{itemize}

\textit{Nota: a existência de SeqScan's pode evidenciar a necessidade de um índice.}\\

\textit{Nota: uma discrepância entre valores previstos/reais pode ser resolvida através do comando VACUUM ANALYSE, que força o recalculo das estatísticas do SGBD.}




\chapter{Transações}
\section{Introdução às Transações}
\begin{definition}[Transação]
    Uma transação é um conjunto de operações de um programa que formam uma unidade lógica de trabalho na qual podem ser acedidos e atualizados vários dados.
\end{definition}
Existem 2 questões a resolver nas transações:
\begin{itemize}
    \itemsep0cm
    \item[--] \textbf{Concorrência}: a execução concorrente de várias transações - resolvida com tem múltiplos processadores disponíveis para múltiplos utilizadores simultâneos;
    \item[--] \textbf{Integridade}: lidar com falhas de vários tipos, nomeadamente de \textit{hardware}, \textit{crashes} do sistema operativo e falhas de \textit{software} do SGBD - resolvida pelas garantidas de integridade do próprio SGBD.
\end{itemize}

Existem, como tal, 3 caminhos possíveis para a conclusão de uma transação:
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.4]{cap_transct/caminhos_transacoes.png}
    \caption{3 caminhos possíveis de uma transação}
\end{figure}

As transações possuem 4 grandes propriedades (\textbf{ACID}):
\begin{itemize}
    \itemsep0cm
    \item[--] \textbf{Atomicidade}: numa transação, as alterações ao estado são \textbf{atómicas}: ou todas se realizam ou nenhuma se realiza - a função do sistema é manter informação sobre as alterações efetuadas por cada transação ativa e, em caso de \textit{crash} ou \textit{abort} explícito, desfazer as alterações feitas desde o início da transação até ao ponto de rutura.
    \item[--] \textbf{Consistência}: uma transação é uma \textbf{transformação correta} do estado, por exemplo, o conjunto das ações da transação não viola nenhuma das regras de integridade associadas ao estado - a função do sistema é assegurar que a base de dados evolui de um estado coerente para outro estado coerente. Os estados coerentes são definidos pela lógica aplicacional.
    \item[--] \textbf{Isolamento}: embora as transações se executem concorrentemente, os estados intermédios de uma transação são invisíveis a todas as restantes transações. Estas vêm apenas ou o estado inicial ou o estado final - a função do sistema é garantir que uma transação apenas "vê" (leituras/escritas) alterações realizadas por transações \textit{committed}.
    \item[--] \textbf{Durabilidade}: uma vez completada uma transação (\textit{commit} concluído), todas as alterações ao estado são imutáveis, sobrevivendo a qualquer falta do sistema - a função do sistema é manter informação sobre alterações efetuadas por cada uma das transações \textit{committed} e, em caso de \textit{crash}m refazer as alterações que ainda não se encontravam registadas em disco.
\end{itemize}

Podemos esquematizar uma transação com o seguinte diagrama de estados:
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.4]{cap_transct/diagrama_estados_trans.png}
    \caption{Diagrama de estados de uma transação}
\end{figure}

\section{Transações em SQL}
Uma \textbf{transação} em SQL consiste na sequência de instruções de consulta e/ou atualização. O SQL \textit{standard} especifica que uma transação começa implicitamente quando uma instrução SQL é executada.

Uma das seguintes instruções SQL deve terminar a transação:
\begin{itemize}
    \itemsep0cm
    \item[--] \textbf{COMMIT [WORK]} confirma a transação ativa; i.e, faz as atualizações realizadas pela transação permanentes na base de dados.
    \item[--] \textbf{ROLLBACK [WORK]} causa a transação ativa a ser desfeita; i.e, desfaz todas as atualizações feitas por instruções SQL na transação, pelo que a base de dados volta ao estado imediatamente antes da transação.
\end{itemize}

\textbf{1)} Seja a seguinte transação: "Escreva uma transação que permita transferir 350€ da conta A para a conta B.". Temos:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
-- Verificar saldos
SELECT balance
FROM account
WHERE account_number='A';

SELECT balance
FROM account
WHERE account_number='B';

-- Transferir 350 euros de A para B
START TRANSACTION;
-- Retirar de A
UPDATE account
SET balance = balance - 350
WHERE account_number='A';
-- Adicionar a B
UPDATE account
SET balance = balance + 350
WHERE account_number='B';
-- Confirmar a transacao
COMMIT;
\end{lstlisting}

Vários sistemas usam \textit{auto-commit} por defeito, onde o início explícito de início de transação é omitido, e cada consulta é uma transação - se houver erros dá \textbf{ROLLBACK} automático, c.c, \textbf{COMMIT} automático.

Para lidar com a concorrência, normalmente usam-se modelos de trincos, e trancam-se tuplos envolvidos numa operação antes de lhes aceder.
Para a seguinte consulta que tenciona ver em que departamento é que os instrutores chamados "João Aragonez" trabalham:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SELECT dept_name
FROM instructor
WHERE name = 'Joao Aragonez';
\end{lstlisting}
seria necessário bloquear toda a relação \textit{instructor}, para assegurar que não possam ser inseridos novos registos com \textit{name} = 'João Aragonez'. Porém, trancar a relação inteira implica acabar com concorrência.

Para combater este problema, existem níveis de isolamento menos exigente, onde algumas operações não exigem 100\% de consistência, por exemplo, o saldo médio de todas as contas registadas num banco, o cálculo de dados estatísticos para otimização de operações. A solução passa por um \textit{trade-off} entre exatidão dos resultados e desempenho do sistema, preferindo que neste tipo de transações, não seja feito a seralização com outras, ou seja, poupam-se as verificações e deixa-se a transação correr livremente em paralelo.

Eis os níveis de consistência em SQL:
\begin{itemize}
    \itemsep0cm
    \item[--] \textbf{Serializable}: por defeito.
    \item[--] \textbf{Repeatable read}: relativamente igual à \textbf{Serializable}, mas permite por exemplo uma transação $T_1$ fazer uma consulta sobre o número de instrutores chamados João Aragonez e haver outra transação $T_2$ que cria ou modifica um tuplo contendo um instrutor chamado João Aragonez antes que $T_1$ seja confirmado.
    \item[--] \textbf{Read committed}: só permite a leitura de tuplos confirmados;
    \item[--] \textbf{Read uncommitted}: qualquer tuplo não confirmado pode ser lido.
\end{itemize}
Para alterarmos o nível de consistência devemos usar o seguinte comando:
\begin{lstlisting}[language=SQL, morekeywords={REFERENCES, REFRESH, MATERIALIZED, CONCURRENTLY, UNCOMMITTED, COMMITTED, REPEATABLE, SERIALIZABLE}, framesep=8pt, xleftmargin=40pt, framexleftmargin=40pt, frame=tb, framerule=0pt]
SET TRANSACTION ISOLATION LEVEL
    { SERIALIZABLE
    | REPEATABLE READ
    | READ COMMITTED
    | READ UNCOMMITTED
    }
\end{lstlisting}

Definimos ainda sobre os níveis de isolamento em SQL:
\begin{itemize}
    \itemsep0cm
    \item[--] \textbf{phantom read}: fazendo a mesma consulta duas vezes, o número de registos pode ser diferente, se entretanto outra transação que inseriu registos foi confirmada.
    \item[--] \textbf{nonrepeatable read}: fazendo a mesma consulta duas vezes, cada registo pode conter dados diferentes, se entretanto outra transação que fez \textbf{UPDATE} foi confirmada.
    \item[--] \textbf{dirty read}: fazendo a mesma consulta duas vezes, é possível ver os dados alterados por outras transações que estão a correr e ainda nem sequer foram confirmadas.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.4]{cap_transct/isolamento_transacoes.png}
    \caption{Consistência e Isolamento em SQL}
\end{figure}

\section{Concorrência}
Logo no 1º capítulo vimos que um SGBD contém um módulo \textit{Concurrency Manager}, que por sua vez garante \textbf{C}oerência e \textbf{I}solamento das transações.

\subsection{Isolamento de Transação e Serialização}
A execução de transações concorrentes \textbf{em série} é ineficiente, pelo que se permite que várias transações corram simultaneamente no sistema. Isto traz algumas \textbf{vantagens}:
\begin{itemize}
    \itemsep 0cm
    \item[--] \textbf{Maior utilização do disco e processadores} - aumento do \textit{throughput};
    \item[--] \textbf{Redução do tempo médio de resposta} das transações.
\end{itemize}

\begin{definition}[Escalonamento/\textit{Schedule}]
    Sequência de instruções que especificam a ordem cronológica na qual as instruções de transações concorrentes são executadas.
    \begin{itemize}
        \itemsep 0cm
        \item[--] Um escalonamento de um conjunto de transações inclui todas as instruções de todas as transações.
        \item[--] \textbf{Tem de preservar a ordem} na qual as instroções aparecem em cada transação individual.
    \end{itemize}
\end{definition}

Um escalonamento diz-se \textbf{serial} se na sequência de instruções das várias transações, as instruções relativas a uma única transação aparecem seguidas.

\begin{figure}[H]%
    \centering
    \subfloat[\centering Escalonamentos em Série]{{\includegraphics[width=8.1cm]{cap_transct/schedule_serial.png} }}%
    \qquad
    \subfloat[\centering Escalonamentos Equivalentes]{{\includegraphics[width=8.1cm]{cap_transct/schedule_eqvlnt.png} }}%
    \caption{Escalonamento de Transações}%
    \label{fig:example}%
\end{figure}

Se repararmos nos escalonamentos equivalentes, notamos que o escalonamento não precisa ser serial para produzir o resultado correto, mas tem de ser \textbf{equivalente} a um escalonamento serial para o considerarmos \textbf{serializável}.

Para os escalonamentos introduzimos uma \textbf{visão simplificada} das transações, considerando apenas as instruções de leitura e escrita na análise destas.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.35]{cap_transct/visao_simplificada.png}
    \caption{Visão simplificada de uma Transação}
\end{figure}

Consideremos agora um escalonamento \textit{S}, no qual existem 2 instruções consecutivas, $I$ e $J$, das transações $T_i$ e $T_j$ respetivamente ($i \neq j$). Se $I$ e $J$ se referirem a objetos diferentes, então podemos trocar $I$ e $J$ sem afetar os resultados de qualquer instrução do escalonamento. Contudo, se se refirem ao mesmo objeto Q, então a ordem destes passos é relevante. Dada a \textbf{visão simplificada} das transações, só consideramos as instruções de leitura e escrita e temos os seguintes 4 casos:
\begin{itemize}
    \itemsep 0cm
    \item[--] $I$: \textbf{read}(Q), $J$: \textbf{read}(Q) - a ordem de $I$ e $J$ é irrelevante, visto que o mesmo valor de Q vai ser lido por $T_i$ e $T_j$, independentemente da ordem;
    \item[--] $I$: \textbf{read}(Q), $J$: \textbf{write}(Q) - se $I$ vem antes de $J$, então $T_i$ não lê o valor de Q que está a ser escrito por $T_j$ na instrução J. Se J vier antes de I, então $T_i$ lê o valor a ser escirot. Logo, a ordem é relevante.
    \item[--] $I$: \textbf{write}(Q), $J$: \textbf{read}(Q) - análogo ao caso anterior.
    \item[--] $I$: \textbf{write}(Q), $J$: \textbf{write}(Q) - visto que ambas as instruções são de escrita, a ordem não afeta nenhuma das transações $T_i$ e $T_j$. Contudo, o valor a ser obtido na próxima instrução de \textbf{read(Q)} de S é afteada, visto que o resultado de apenas 1 das escritas é preservado na base de dados. Assim, a ordem é também relevante.
\end{itemize}

Dizemos então que $I$ e $J$ têm um \textbf{conflito} se são operações de \textbf{transações diferentes} que acedem ao mesmo objeto, e pelo menos 1 dessas instruções é uma \textbf{escrita}.

Se $I$ e $J$ são instruções de transações diferentes e não têm conflito entre si, então podemos trocar a ordem para criar um novo escalonamento \textbf{S'}, que é equivalente a \textbf{S}, visto que todas as instruções estão na mesma ordem exceto para $I$ e $J$, cuja ordem é irrelevante - se um escalonamento \textbf{S} pode ser transformado noutro escalonamento \textbf{S'} por uma série de trocas de instruções não-conflituosas, diz-se que \textbf{S} e \textbf{S'} são \textbf{equivalentes sem conflitos}.
Dizemos também que um escalonamento \textbf{S} tem \textbf{conflitos serializáveis} se é equivalente a um escalonamento serial.

\begin{figure}[H]%
    \centering
    \subfloat[\centering Escalonamento com Conflito Serializável]{{\includegraphics[width=4.1cm]{cap_transct/sch_confl_ser.png} }}%
    \qquad
    \subfloat[\centering Escalonamento com Conflito Não Serializável]{{\includegraphics[width=8.1cm]{cap_transct/sch_non_confl_ser.png} }}%
    \caption{Escalonamento com Conflitos}%
    \label{fig:example}%
\end{figure}
De notar que a figura em (b) tem um conflito não serializável, pois se tivéssemos $<T_3 , T_4>$, o próximo \textbf{read}(Q) iria ler o resultado da transação $T_4$, e se tivermos $<T_4 , T_3>$ a transação $T_3$ irá ler o valor da escrita em $T_4$.

Uma maneira simples e eficiente de determinar conflitos de serialização num escalonamento é construir um \textbf{grafo de precedência} a partir de um escalonamento \textbf{S}. O grafo consiste num par $G = (V, E)$, onde $V$ é um conjunto de vértices e $E$ um conjunto de arestas. O conjunto de \textbf{vértices} $V$ é dado por todas as transações $T_i$ que participam no escalonamento. O conjunto de \textbf{arestas} consiste em todas as arestas $T_i \rightarrow T_j$ no qual 1 das 3 condições se verificam:
\begin{itemize}
    \itemsep 0cm
    \item[--] $T_i$ executa \textbf{write}(Q) antes de $T_j$ executar \textbf{read}(Q);
    \item[--] $T_i$ executa \textbf{read}(Q) antes de $T_j$ executar \textbf{write}(Q);
    \item[--] $T_i$ executa \textbf{write}(Q) antes de $T_j$ executar \textbf{write}(Q);
\end{itemize}

Se uma aresta $T_i \rightarrow T_j$ existe no grafo de precedência, então em qualquer escalonamento serial \textbf{S'} equivalente a \textbf{S}, $T_i$ tem de aparecer \textbf{antes} de $T_j$.

\begin{figure}[H]%
    \centering
    \subfloat[\centering Escalonamento Serializável]{{\includegraphics[width=7cm]{cap_transct/grafo_prec_1.png} }}%
    \qquad
    \subfloat[\centering Escalonamento Não Serializável]{{\includegraphics[width=7cm]{cap_transct/grafo_prec_2.png} }}%
    \caption{Escalonamento Serializável}%
    \label{fig:example}%
\end{figure}

Um escalonamento é \textbf{serializável} se o seu grafo de precedências não tiver ciclos - se o grafo for acíciclo, podemos obter uma \textbf{ordenação topológica} e executar as transações sobre uma qualquer. De notar que isto é uma condição \textbf{suficiente}, mas não \textbf{necessária}, pois existem casos de escalonamentos serializáveis cujo grafo de precedência contém um ciclo.

\subsection{Isolamento e Atomicidade de uma Transação}
Até agora vimos escalonamentos que assumem que não existem falhas nas transações.

Se uma transação $T_i$ falha, precisamos reverter os seus efeitos, e os efeitos de qualquer transação $T_j$ que esteja a ser executada concorrentemente com $T_i$ e que dependa desta.

Um \textbf{escalonamento parcial} define-se por \textbf{não ter} as operações de \textbf{commit} ou \textbf{abort} em todas as transações que este abrange, como é o caso do escalonamento abaixo.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{cap_transct/irrecuperavel_esc.png}
    \caption{Escalonamento não recuperável}
\end{figure}
Como $T_7$ confirma a transação logo a seguir a ler A, i.e., ainda quando $T_6$ está ativa. Se $T_6$ falhar antes de confirmar, terá de reverter todas as suas instruções e $T_7$ já confirmou uma transação de um valor que fora revertido - $T_7$ é \textbf{dependente} de $T_6$, pelo que devemos abortar também $T_7$ por questões de atomicidade. Como tal, diz-se que este escalonamento é \textbf{não-recuperável}.

\begin{definition}[Escalonamento Recuperável]
    Um escalonamento diz-se recuperável sse para cada par de transações $T_i$ e $T_j$, tal que $T_j$ lê dados escritos previamente por $T_i$, então a confirmação de $T_i$ tem de aparecer antes da confirmação de $T_j$.
\end{definition}

Para o exemplo acima ser recuperável, $T_7$ teria de esperar até $T_6$ confirmar para poder confirmar a sua própria transação.

Isto pode criar o efeito de \textbf{rollbacks em cadeia}, como é o seguinte caso:
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{cap_transct/cadeia_rollback.png}
    \caption{Rollbacks em cadeia}
\end{figure}

Uma pequena extensão que se fazem às transações são \textbf{savepoints} - são usados dentro das transações como "pontos seguros" das aplicações cujo estado é conhecido e a partir dos quais a computação pode recomeçar. Os \textbf{rollbacks} podem ser para \textbf{savepoints}.

\subsection{Protocolo de Isolamento com Trincos}
Uma maneira de assegurar isolamento é requisitar que objetos de dados sejam acedidos por exclusão mútua, i.e, se uma transação acede um objeto, nenhuma outra transação pode modificar esse mesmo - para isso usamos \textbf{trincos}.

Existem 2 modos de trincos sobre objetos:
\begin{itemize}
    \itemsep 0cm
    \item[--] \textbf{Partilhado}. Se uma transação $T_i$ obteve um \textbf{trinco partilhado} (seja este \textbf{S}) no objeto Q, então $T_i$ pode ler, mas não pode escrever em Q.
    \item[--] \textbf{Exclusivo}. Se uma transação $T_i$ obteve um \textbf{trinco exclusivo} (seja este \textbf{X}) no objeto Q, então $T_i$ pode ler e escrever em Q.
\end{itemize}
A transação \textbf{pede} o modo de trinco apropriado de acordo o tipo de operações que vai executar sobre o objeto Q - o pedido é feito ao \textit{Concurrency Control Manager} do SGBD, e bloqueia até lhe ser concedido (fica em \textit{wait-state}).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.45]{cap_transct/matriz_compatibilidade.png}
    \caption{Matriz de Compatibilidade dos Modos de Trinco}
\end{figure}

De forma simples, o protocolo de acesso a objetos nas transações concorrentes é dado por:
\begin{itemize}
    \itemsep 0cm
    \item[--] Uma transação tem que adquirir um trinco \textbf{partilhado} antes de tentar ler o valor de um tuplo.
    \item[--] Uma transação tem que adquiri um trinco \textbf{exclusivo} antes de tentar escrever o valor de um tuplo.
    \item[--] Os trincos são \textbf{libertados} aquando da confirmação da transação.
\end{itemize}

\subsection{Protocolo Two-Phase Locking}
O \textbf{protocolo two-phase locking} assegure serialização. Requer que cada transação emita pedidos de bloqueio e desbloquio de trinco em 2 fases:
\begin{itemize}
    \itemsep 0cm
    \item[--] Fase \textbf{Crescente}/\textit{Growing Phase}: uma transação pode obter trincos, mas não pode libertá-los;
    \item[--] Fase \textbf{Decrescente}/\textit{Shrinking Phase}: uma transação pode libertar trincos, mas não pode obter nenhum trinco novo;
\end{itemize}
Inicialmente uma transação está na fase crescente e adquire trincos à medida que necessita. Mal liberte um dos trincos, entra na fase decrescente e não pode emitir mais pedidos.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{cap_transct/trincos_tempo_2pl.png}
    \caption{Gráfico de Trincos vs Tempo no 2PL}
\end{figure}

Rollbacks por cascata podem ser evitado usando uma modificação do \textit{2PL} chamada \textbf{Protocolo Strict Two-Phase Locking} - igual à 2PL, porém os trincos \textbf{exclusivos} ficam trancados até a transação ter sido confirmada. Outra variante é o \textbf{Protocolo Rigorous Two-Phase Locking} - igual à S2PL, mas aplica-se também aos trincos partilhados e não só aos exclusivos.

Por fim à concorrência, existe também uma política de controlo de concorrência alternativa aos trincos - \textbf{timestamps}. Se a transação $T_1$ iniciou a execução antes de $T_2$, então o sistema deve garantir o resultado da serialização \{$T_1, T_2$\}, oue seja, $T_1$ não pode ler dados alterados por $T_2$ e $T_1$ não pode alterar dados que $T_2$ já tenha lido.

\section{Recuperação}
Uma parte integral de um SGBD é um \textbf{esquema de recuperação} que consegue restaurar a base de dados para um estado consistente que existia antes da falha.

\subsection{Classificação de Falha}
Existem duas categorias de falhas:
\begin{itemize}
    \itemsep 0cm
    \item[--] \textbf{Falhas de sistema} - afeta as transações no sistema, sem haver deficiência permanente nele. (ex.: falta de corrente elétrica, erro de software);
    \item[--] \textbf{Falhas de componentes} - existe uma avaria num dos componentes do sistema. (ex.: avaria do disco rígido).
\end{itemize}

\subsection{Armazenamento}
Quando o SGBD arranca após uma falta tem que recuprar as transações em curso, analisando um \textbf{registo de log} e refazer as transações com confirmação aceite e desfazer as que não têm - só depois é que o sistema está operacional.

Existem 3 tipos de armazenamento:
\begin{itemize}
    \itemsep 0cm
    \item[--] Armazenamento volátil: não sobrevive ao \textit{crash} e \textit{boot} do sistema;
    \item[--] Armazenamento não-volátil: sobrevive ao \textit{crash} e \textit{boot} do sistema;
    \item[--] \textbf{Armazenamento estável}: tem a redundância de \textit{hardware} para permitir N falhas de \textit{hardware}.
\end{itemize}

O \textbf{armazenamento estável} desempenha um papel crítico em algoritmos de recuperação.
\end{document}
